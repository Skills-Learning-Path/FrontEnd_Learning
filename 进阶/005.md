> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [blog.csdn.net](https://blog.csdn.net/qq_39053584/article/details/93997318)

# Angualr 入门扫盲必备

A: 环境, 工具
=========

### 1: 先确保安装了 [nodejs](https://so.csdn.net/so/search?q=nodejs&spm=1001.2101.3001.7020) 和 npm

在开始之前，请确保你的开发环境中包括 Node.js 和 npm 包管理器

##### Nodejs

Angular 需要 Node.js 版本 10.9.0 或更高版本。要检查你的版本，请在终端 / 控制台窗口中运行 node -v 。  
windows 更新版本不能通过网上说的安装 n 模块更新, 只能重新下载新版的 nodejs _重新安装覆盖._

> 要获取 Node.js，请转到 [nodejs.org](https://nodejs.org/en/)。

##### npm 包管理器

Angular、Angular CLI 和 Angular 应用都依赖于 npm 包中提供的特性和功能。要想下载并安装 npm 包，你必须拥有一个 npm 包管理器。  
本搭建指南使用 npm 客户端命令行界面，Node.js 已经默认安装了它。  
要检查你是否安装了 npm 客户端，请在终端 / 控制台窗口中运行 npm -v 。

##### cnpm(淘宝的镜像)

一般的项目通过 npm install(npm 是干啥的等会再说) 项目时不会有什么错误, 只会[时间比较](https://so.csdn.net/so/search?q=%E6%97%B6%E9%97%B4%E6%AF%94%E8%BE%83&spm=1001.2101.3001.7020)长, 这时候有人推荐用 cnpm, 下面是如何安装 cnpm:

```
npm install -g cnpm --registry=https://registry.npm.taobao.org
```

通过 cnpm -v 可以检查是否安装成功

### 2: 安裝 angualr cli

你可以使用 Angular CLI 来创建项目、生成应用和库代码，以及执行各种持续开发任务，比如测试、打包和部署。  
https://www.angular.cn/guide/setup-local#step-1-install-the-angular-cli

*   查看 angualr 的版本命令: ng --version
*   卸載當前的 cli 並安裝指定版本的 angular: https://www.jianshu.com/p/268dd2a94471
*   _我裝的最新版用的是: npm install -g @angular/cli_

### 3: 工具

##### VSCode 的 angular 插件

VSCode 的下载安装就不说了, 安装 angualr 插件直接在 VSCode 里面搜索 Angualr, 点击下载量多的就可以. 下面列举一点:

> *   TSLint：Typescript 语法检查 Prettier：代码格式化 IntelliJ IDEA
> *   Keybindings：IDEA 风格的快捷键
> *   Angular 7 Snippets：Angular 语法填充（标签）
> *   Angular Files：生成 Angular 的文件模板（Component、Module、Pipe 等等）
> *   Angular Follow Selector：文件跳转（Component 跳转到 html、scss 文件）
> *   Angular Language Service：引用填充和跳转到定义（html 中进行引用补全）
> *   Debugger for Chrome：调试 Angular 代码

##### VSCode 快捷键:

vscod 快捷鍵: https://code.visualstudio.com/docs/getstarted/keybindings

##### VSCode 调试 Angular 代码:

https://www.cnblogs.com/cxd1008/p/7681522.html

B: 新建 Angualr 项目
================

### 1: 新建项目 angualrDemo

```
ng new angualrDemo --skip-install
```

注: 如果按照官网的教程只用输入 ng new 项目名 即可, 但是这种情况下它会默认使用 npm 帮我们创建项目并且安装各种依赖, 非常耗时间, 所以我们后面加上 -- skip-install 跳过安装依赖的过程.

### 2:VSCode 操作项目

##### VSCode 导入项目

打开项目文件夹, 可以看到项目结构  
![](https://img-blog.csdnimg.cn/2019070414281464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)

> e2e 文件夾: e2e 測試用的 tsconfig.json ，这是 TypeScript 编译器配置文件 typings.json  
> 文件用于在 Angular 应用程序中标识 TypeScript 定义文件 -core-js : 它为我们的 ES5 浏览器带来 ES2015 /  
> ES6 功能。  
> -jasmine : 这是 Jasmine 测试框架的类型。  
> -node : 它用于引用 nodejs 环境中的对象的代码。 package.json 将包含我们的应用所需的包。 这些包使用 npm(节点程序包管理器) 进行安装和维护 environment_main.ts 文件告诉 Angular 加载组件  
> Angular-cli.json 里面配置了项目的几本信息，包括版本名字之类的 package.json 是 npm 包配置  
> tslint 是一种标准化代码检查的东西 polyfills.ts  
> 这里面放项目所必须的第三方 js,angular-cli 监理的项目里面包括了一些东西，不用管，之后要用到的其他 js 库可以直接在这里面添加.

##### cnpm 安装依赖

创建之后我用 cnpm 安装依赖 (上面讲了如何安装 cnpm)

```
cnpm install
```

发现项目结构会多一个文件夹, 里面就是 install 的依赖  
![](https://img-blog.csdnimg.cn/20190704142942547.png)

##### 根模块 app.module.ts

![](https://img-blog.csdnimg.cn/20190704113555462.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)

##### 根组件 app.component.ts

![](https://img-blog.csdnimg.cn/20190704143939563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)

##### 创建新的組件 news

生成組件:

> ng g component commons/news

例如: ng g component commons/news(文件夾 / 組件名)  
這樣會自動在 app 下面創建一個 commons 文件夾並且在 commons 文件夾下面創建一個 news 組件, 並且自動在 app.moudle.ts 裡面添加 news 組件的引入.  
![](https://img-blog.csdnimg.cn/20190704144456324.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)

##### 在跟组件里面引用 news 组件

![](https://img-blog.csdnimg.cn/2019070414520499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)

##### 启动项目

ng serve 默认启动在端口 4200  
ng serve – open, 启动并打开浏览器

```
ng serve --port 端口
```

C: 属性操作, 元素操作, 指令
=================

我们先把 app.component.html 里面的自动生成的内容删掉, 以免干扰

### 1: 定义普通数据

![](https://img-blog.csdnimg.cn/20190704155622894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)  
打开页面:  
![](https://img-blog.csdnimg.cn/20190704155829354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)

### 2: 定义数组及用 * ngFor 循环

![](https://img-blog.csdnimg.cn/20190704163111354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)  
打开页面:  
![](https://img-blog.csdnimg.cn/20190704163208976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)

### 3: 图片的引入

新建一个 home 的组件:

```
ng g component commons/home
```

在 app.component.html 里引入,  
![](https://img-blog.csdnimg.cn/20190704170915508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)  
页面上:  
![](https://img-blog.csdnimg.cn/20190704171023594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)

### 4:ngSwitch, ngIf

![](https://img-blog.csdnimg.cn/20190704171253727.png)  
**ngif** 查看该问文章: https://www.jianshu.com/p/33bbe72a682e

### 5:ngClass,ngStyle

**ngClass**  
![](https://img-blog.csdnimg.cn/20190704173134368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190704173209283.png)  
**ngStyle**  
![](https://img-blog.csdnimg.cn/20190704173749989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190704173818510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)

### 6: 管道

> 比如说很多时候我们需要把数字显示成金额、大小写转换、日期小数转换等等。 Angular 管道对于象这样小型的转换来说是个很方便的选择。  
> 管道是一个简单的函数，它接受一个输入值，并返回转换结果。  
> ![](https://img-blog.csdnimg.cn/20190704174453956.png)

常见管道: http://bss.itying.com/topic/5bf519657e9f5911d41f2a34

D: 事件
=====

### 1: 普通点击事件

![](https://img-blog.csdnimg.cn/20190704175650125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)  
这里只是演示事件, 数据的双向绑定会有更好的方法: 后面提到.

### 2: 表单事件, 事件对象

![](https://img-blog.csdnimg.cn/20190704180903568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)

E: 双向数据绑定 (!!!)
===============

1.  首先在 app.module.ts 里面引入并声明;
2.  再在 input 里使用 [(ngModel)]="inputVal" 双向绑定数据
3.  home.component.ts 里面的方法为了测试通过 model 来改变视图

如下图  
![](https://img-blog.csdnimg.cn/2019070419311897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)  
打开页面, input 框和后面显示的值是 1, 点击按钮几下, 两个地方的值一起变化  
![](https://img-blog.csdnimg.cn/20190704193529152.png)

F: 双向数据绑定获取各种表单值实现一个小项目 1
=========================

之前的项目里面杂碎太多，页面显示太混乱，现在把 app.component.html 里面的东西全部注释掉。  
**再次提醒：** 因为要使用双向数据绑定，所以别忘了在 app.module.ts 里面引入相应模块。  
下面的内容包括 **input,checkbox,radio,select,textarea**

### 1: 创建组件 form

```
ng g component common/form
```

在 app.component.html 里面引用刚创建的组件，加上 `<app-form></app-form>`，利用命令创建的组件会在 app.module.ts 里自动添加引入，所以我们不需要去手动添加。

### 2:form.component.html

```
<h2>人员登记系统</h2>
<div class="people_list">
    <ul>
        <li>姓名：<input class="form_input" type="text" id="username" [(ngModel)]="peopleInfo.username"></li>
        <li>性别：                                                  
                <!-- 这里的label 是为了点击文字能选中按钮 -->
            <input  type="radio"  [(ngModel)]="peopleInfo.sex"><label for="sex1">男  </label>       
            <input  type="radio"  [(ngModel)]="peopleInfo.sex"><label for="sex2">女</label> 
        </li>
        <li>城市：                                                  
            <select  [(ngModel)]="peopleInfo.city">
                <option [value]="c" *ngFor="let c of peopleInfo.citylist">{{c}}</option>
            </select>
        </li>
        <li>爱好：     
            <!--这里的双向数据绑定重点，难  -->
            <span *ngFor="let h of peopleInfo.hobby;let k=index;">
            <input [(ngModel)]="h.checked" type="checkbox" [id]="'check'+k" /><label [for]="'check'+k">{{h.title}}</label>
               
            </span>
        </li>
        <li>优点:
            <textarea  [(ngModel)]="peopleInfo.mark"></textarea>
        </li>
    </ul>

    <button (click)="doSubmit()" class="submitbtn">获取表单内容</button>
    <br><br>
    <pre>
        <!-- 利用转换成json的方式 -->
        {{peopleInfo | json}}

    </pre>
</div>
```

### 3:form.component.ts

```
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-form',
  templateUrl: './form.component.html',
  styleUrls: ['./form.component.css']
})
export class FormComponent implements OnInit {
  public peopleInfo : any = {
    username : 'Kone.wang',
    sex:'1',
    citylist:['安徽','北京','上海','广州'],
    city:'上海',
    hobby:[{
      title:'吃饭',
      checked:false
    },
    {
      title:'睡觉',
      checked:false
    },
    {
      title:'敲代码',
      checked:true  
    }],
    mark:'请在这里说明你的5个优点'
  }

  constructor() { }
  doSubmit(){
  /**
   * jquery操作：可用，但不推荐
   * let usernameDom:any=document.getElementById('username');
   * console.log(usrnameDom.value);
   * 推荐下面的利用双向数据绑定获取值
   */
    console.log(this.peopleInfo);
  }
  ngOnInit() {
  }
}
```

### 4:form.component.css

```
h2{
    text-align: center;
}
.people_list{
    width:400px;
    margin:50px auto;
    padding: 20px;
    border: 1px solid #eee;
}
li{
    height: 50px;
    line-height: 50px;
  
}
li .form_input{
    width:300px;
    height: 25px;
}
.submitbtn{
    width: 100px;
    height: 30px;
    float: right;
    margin-right: 50px;
    margin-top: 40px;

}
```

### 5: 全局样式 style.css

```
*{
    margin: 0px;
    padding: 0px;
}
ol,ul{

    list-style-type: none;
}
```

### 6: 阶段成果

![](https://img-blog.csdnimg.cn/20190705000201922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)

G: 类似京东做搜索缓存数据功能
================

为了避免 F 中的项目文件干扰, 我在 app.component.html 里面引入的`<app-form></app-form>`注释掉, 文件都没删除, 毕竟是学习的记录, 保留着.  
**我们接下来的功能就是类似各种网站搜索的历史记录, 搜索框输入的内容点击搜索之后, 会在下方的搜索历史里展示出来, 并且实现删除单条搜索记录的功能**  
接下来我再新建一个组件:`ng g component commons/search`  
并在 app.component.html 里引入:`<app-search></app-search>`

### 1:search.component.html

```
<div class="search">
    <input type="text" [(ngModel)]="keyword" />
    <button (click)="doSearch()" class="searchbtn" >搜索</button>
    搜索历史
    <hr>
    <ul>
        <li *ngFor="let item of historyList;let k=index;" >{{item}}   
            <button (click)="deleteHistory(k)" >刪除</button>
        </li>
    </ul>
</div>
```

### 2:search.component.ts

```
export class SearchComponent implements OnInit {
  public keyword:string='';
  public historyList:any[]=[];

  doSearch(){
    if(this.historyList.indexOf(this.keyword) == -1){
      this.historyList.push(this.keyword);
    }
    this.keyword='';
  }
  deleteHistory(k){
    this.historyList.splice(k,1);
  }
  constructor() { }
  ngOnInit() {
  }
}
```

### 3:search.component.css

```
.search{
    width: 400px;
    margin: 20px auto;
    background-color: lightcyan;
}
input{
    margin-bottom: 20px;
    width: 300px;
    height: 32px;
    background-color: lavenderblush;
}
.searchbtn{
    height: 32px;
    width: 80px;
}
```

### 4: 阶段成果

![](https://img-blog.csdnimg.cn/20190705141610539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)  
_当然这里的数据会在刷新页面之后丢失, 没能持久化, 持久化会在后面讲到._

H:TodoList(待办事项和已完成事项)
======================

**这一个 demo 完成一个记录当前未做的任务, 并且可以实现把已完成任务变成未完成任务的功能. 也是用来练习数据双向绑定和属性绑定 [hidden]=“item.status==1”**  
注释掉上一个功能在 app.component.html 里面的引入.  
创建一个新的组件:`ng g component commons/todolist`

### 1:todolist.component.html

```
<h2>ToDoList</h2>
<div class="todolist">
    <input class="form_input" type="text" [(ngModel)]="keyword" (keyup)="doAdd($event)"  />
    <hr>
    <h3>待办事项</h3>
    <ul>
        <li *ngFor="let item of todolist;let k=index;" [hidden]="item.status==1"  >
            <input type="checkbox" [(ngModel)]="item.status" />
            {{item.title}}-----<button (click)="deletejob(k)" >X</button>
        </li>
    </ul>
    <h3>已完成事项</h3>
    <ul>
            <li *ngFor="let item of todolist;let k=index;" [hidden]="item.status==0"  >
                <input type="checkbox" [(ngModel)]="item.status" />
                {{item.title}}-----<button (click)="deletejob(k)" >X</button>
            </li>
    </ul>
</div>
```

### 2:todolist.component.ts

```
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-todolist',
  templateUrl: './todolist.component.html',
  styleUrls: ['./todolist.component.css']
})
export class TodolistComponent implements OnInit {
  keyword:string='';
  todolist:any[]=[];
  //添加任务
  doAdd(e){
    if(e.keyCode == '13'){
      if(!this.isChongfu(this.keyword,this.todolist)){
        this.todolist.push({
          title:this.keyword,
          status:0  //默认写0,表示待办事项.1为已完成事项
        });
        this.keyword=''
      }else{
        alert("不要重复添加");
      }
    }
  }
  //删除单项任务
  deletejob(k){
    this.todolist.splice(k,1);
  }
  //封装一个方法,过滤重复的keyword
  isChongfu(keyword:any,todolist:any){
    //异步的,存在问题,导致每次都返回false
    // todolist.forEach(v => {
    //   if(v.title == keyword){
    //     return true;
    //   }
    // });
    if(! keyword) return true;
    for(var i=0;i<todolist.length;i++){
      if(todolist[i].title==keyword){
        return  true;
      }
    }
    return false;
  }
  constructor() { }

  ngOnInit() {
  }
}
```

### 3:todolist.component.css

```
h2{
    text-align: center;
}
.todolist{
    width: 400px;
    margin: 20px auto;
    background-color: lightcyan;
}
.form_input{
    margin-bottom: 20px;
    width: 300px;
    height: 32px;
    background-color: lavenderblush;
}
.searchbtn{
    height: 32px;
    width: 80px;
}
ul,ol{
    list-style-type: none;
}
li{
    margin-top: 20px;
}
```

### 4: 阶段成果

![](https://img-blog.csdnimg.cn/20190705155617709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)  
好的, 还是没能数据持久化. 那么下面讲讲

I: 服务
=====

### 1: 准备

把之前 F 功能和 G 功能的代码注释去掉, 这样的话我们的 app.component.html 里面就放了`<app-search></app-search> <app-todolist></app-todolist>`这两个组件.

### 2: 创建服务

cli 指令创建服务:`ng g service 服务名`  
我为了方便管理, 指定一下 service 存放的目录, 所以我直接在后面追加路径:

```
ng g service services/storage
```

自动生成了两个文件 storage.service.ts 和另外一个测试文件  
然后在 **app.module.ts** 里面 import 这个服务.(只是列增加的代码)

```
//引入并配置服务
import { StorageService } from './services/storage.service';
providers: [StorageService],//配置服务
```

### 3: 定义服务的方法给其他两个组件使用

#### 首先在 stroage.service.ts 写测试方法

**stroage.service.ts**

```
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class StorageService {
  //测试方法
  test1(){
    return 'this just a test by kone';
  }
  constructor() { }
}
```

#### 组件里使用 service

我们在之前的两个组件: search.component.ts 和 todolist.component.ts 里面使用这哥服务的 test1 方法.  
先在上面两个文件中引入这个服务

```
import { StorageService } from './../../services/storage.service';
```

然后在构造函数中实例化并且调用 test1 方法

```
/**
  可用,但不推荐
  var newSS=new StorageService();
  console.log(newSS.test1());
 */
  constructor(public ss:StorageService) {
    console.log(ss.test1() );
 }
```

#### 测试服务引用

![](https://img-blog.csdnimg.cn/20190705164243914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)  
可以看到两个组件都成功调用了 stroage.service.ts 中 test1 方法

J: 数据持久化到 localStroage
======================

之前的 search 和 todolist 两个组件的数据在刷新页面之后数据就没有了. 接下来我们在 service 里面创建公共的持久化数据方法 (这种数据放到 H5 的 localStroage 里面即可),

### 1: 先在服务里定义方法

stroage.service.ts 增加下面三个方法

```
set(key:string,value:any){
    localStorage.setItem(key,JSON.stringify(value));
  }
  get(key:string){
    return JSON.parse(localStorage.getItem(key));
  }
  remove(key:string){
    localStorage.removeItem(key);
  }
```

### 2: 组件里调用 service 的方法

search.component.ts 和 todolist.component.ts 两个组件的里面引入和实例化 service 上一阶段已经讲过了. 下面直接在这两个文件中调用这个方法.  
**search.component.ts:**

```
import { Component, OnInit } from '@angular/core';
import { StorageService } from './../../services/storage.service';
@Component({
  selector: 'app-search',
  templateUrl: './search.component.html',
  styleUrls: ['./search.component.css']
})
export class SearchComponent implements OnInit {
  public keyword:string='';
  public historyList:any[]=[];
  constructor(public ss:StorageService) {
    console.log(ss.test1() );
  }
  ngOnInit() {
    var searchlist=this.ss.get('searchlist');
    this.historyList=searchlist;
  }
  doSearch(){
    if(this.historyList.indexOf(this.keyword) == -1){
      this.historyList.push(this.keyword);
      this.ss.set('searchlist',this.historyList);
    }
    this.keyword='';
  }
  deleteHistory(k){
    this.historyList.splice(k,1);
    this.ss.set('searchlist',this.historyList);
  }
}
```

**todolist.component.ts**

```
import { Component, OnInit } from '@angular/core';
import { StorageService } from './../../services/storage.service';
/**
  可用,但不推荐
  var newSS=new StorageService();
  console.log(newSS.test1());
 */

@Component({
  selector: 'app-todolist',
  templateUrl: './todolist.component.html',
  styleUrls: ['./todolist.component.css']
})

export class TodolistComponent implements OnInit {
  keyword:string='';
  todolist:any[]=[ ];
  constructor(public ss:StorageService) {
    console.log(ss.test1());
  }
  //页面初始化就触发这个方法
  ngOnInit() {
    var lists=this.ss.get('todolist');
    if(lists)
      this.todolist=lists;
  }
  //添加任务
  doAdd(e){
    if(e.keyCode == '13'){
      if(!this.isChongfu(this.keyword,this.todolist)){
        this.todolist.push({
          title:this.keyword,
          status:0  //默认写0,表示待办事项.1为已完成事项
        });
        this.ss.set('todolist',this.todolist);
        this.keyword=''
      }else{
        alert("不要重复添加");
      }
    }
  }
  //删除单项任务
  deletejob(k){
    this.todolist.splice(k,1);
    //删除之后要重新更新localStroage里面数据
    this.ss.set('todolist',this.todolist);
  }
  //改变checkbox之后也要舒心缓存
  changebox(){
    this.ss.set('todolist',this.todolist);
  }
  //封装一个方法,过滤重复的keyword
  isChongfu(keyword:any,todolist:any){
    //异步的,存在问题,导致每次都返回false
    // todolist.forEach(v => {
    //   if(v.title == keyword){
    //     return true;
    //   }
    // });
    if(! keyword) return true;
    if(todolist==null) return false;
    for(var i=0;i<todolist.length;i++){
      if(todolist[i].title==keyword){
        return  true;
      }
    }
    return false;
  }
}
```

这个 todolist.component.ts 里面增加了一个 changebox() 方法, 所以在 todolist.component.html 里面的 checkbox 上增加方法调用 (change)=“changebox()”

### 4: 阶段成果

![](https://img-blog.csdnimg.cn/20190705175903537.gif)

K: 父子或非父子组件之间的通信, 传值
====================

重新建一个项目, 然后 cnpm install 之后再新建 4 个组件: news,home,header,footer.  
这里, news 和 header 是父子组件关系, home 和 footer 是父子组件关系.

### 1: 父组件给子组件传值 @input

news 和 header 是父子组件关系  
**父组件可以把属性, 方法, 甚至整个父组件传递给子组件**  
![](https://img-blog.csdnimg.cn/20190708095713204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)  
我们先看一下上面流程, 再做.  
先把 app.component.html 里面自动生成的代码去掉并引入 news 组件, 然后在 news 组件的 html 里面引入 header 组件.  
![](https://img-blog.csdnimg.cn/20190708102542295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)  
父组件给子组件传值, 也就是子组件需要使用父组件的属性和方法, 按照三步走:

> 父组件给子组件传数据  
> 子组件引入 Input 模块  
> 子组件 @Input 接受传过来的数据

### 子组件给父组件传值

##### 父组件通过 @ViewChild 主动获取子组件的数据和方法

home 和 footer 是父子组件关系. 我们把 app.component.html 里面的引入替换成`<app-home></app-home>`, 并且在 home 组件中引入`<app-footer></app-footer>`  
![](https://img-blog.csdnimg.cn/20190708105043755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)

##### 子组件通过 @OutPut 触发父组件

没了解, 用到的时候再百度吧.

L: 数据交互 (Get,Post,jsonp)
========================

这里我只记录 angular 内置的 HttpClientModule 的数据交互方式

### 1：Get

![](https://img-blog.csdnimg.cn/20190710092152634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)

### 2:Post

先准备好后台服务的接口：  
很显然，我写了两个 post 的方法，一个是用 RequestBody 接受参数，另一个是用 RequestParam 接受参数的。

##### 后台接口

```
package com.example.angulartest;
import com.sun.org.apache.xpath.internal.operations.String;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.Map;
@RestController
@CrossOrigin(origins = "http://localhost:4200")
public class TestController {
    //用RequestBody接受数据
    @RequestMapping(value = "/testPostBody",method = RequestMethod.POST)
    public Map testPostBody(@RequestBody  Map<Object,Object> jsonString){
        System.out.println("jsonString : "+jsonString.get("uname")+"---------"+jsonString.get("pword") );
        return jsonString;
    }
    //@RequestParam接受数据
    @RequestMapping(value = "/testPostPara",method = RequestMethod.POST)
    public Map<String, String> testPostPara(@RequestParam Object uname,
                                            @RequestParam Object pword){
        System.out.println("jsonString : "+uname+"---------"+pword );
        Map map=new HashMap();
        map.put("uname",uname);
        map.put("pword",pword);
        return map;
    }
}
```

##### angular 中引入相关模块

ap.module.ts 中引入

```
import { HttpClientModule } from '@angular/common/http';
```

```
imports: [
    BrowserModule,
    AppRoutingModule,
    HttpClientModule
  ],
```

然后在使用的地方再引入

```
import { HttpClient, HttpHeaders } from '@angular/common/http';
```

并且再构造函数中实例化 HtpClient,  
测试代码：

```
import { Component, OnInit } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';

@Component({
  selector: 'app-news',
  templateUrl: './news.component.html',
  styleUrls: ['./news.component.css']
})
export class NewsComponent implements OnInit {
  constructor(public http: HttpClient) { }

  testPostBody() {//post请求，参数在body中
    const header = {headers: new HttpHeaders({'Content-Type': 'application/json'})};
    let url = "http://localhost:8080/testPostBody";
    this.http.post(url,{ 'uname': 'kone', 'pword': '2222222222'},header).subscribe(re=>{
        console.log(re);
    });
  }
  testPostPara(){//post请求，参数在url后面
    const header = {headers: new HttpHeaders({'Content-Type': 'application/json'})};
    let url = "http://localhost:8080/testPostPara?u;
    //body中就不放入参数，直接拼接到url后面
    this.http.post(url,{},header).subscribe(re=>{
        console.log(re);
    });
  }
  ngOnInit() {
  }
}
```

##### 效果

![](https://img-blog.csdnimg.cn/20190708234928141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)

M: 路由
=====

我现在对路由作用的理解是：

> 1: 根据不同的 url 地址，动态的让根组件（父组件）挂载其他组件来实现一个单页面应用  
> 2：在分页的查询的情况下能通过 url 栏分享出当前的页数或者 detail 信息

### 1: 创建路由

在用 ng new 新项目时，第一步问你要不要加入路由：

```
Would you like to add Angular routing? (y/N)
```

此时，我们输入 y 创建。然后在生成的文件中看到下图，并且在 app.module.ts 里面也自动引入了路由模块。  
![](https://img-blog.csdnimg.cn/2019070900033947.png)  
在 app-routing.module.ts 里面配置项目的路由即可  
![](https://img-blog.csdnimg.cn/20190709000515871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)  
还有 app.component.html 底部多了一行标签`<router-outlet></router-outlet>`。这个接下来就会一并讲到。

### 2: 准备几个组件

```
ng g component components/product
ng g component components/news
ng g component components/home
```

然后在 app-routing.module.ts 中引入这几个组件

### 3: 配置路由

打开 app-routing.module.ts，此时你应该在这里面引入了这几个组件，然后开始配置

```
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';
import { HomeComponent } from './components/home/home.component';
import { NewsComponent} from './components/news/news.component';
import { ProductComponent } from './components/product/product.component';

// 这里配置路由
const routes: Routes = [
  {path: 'home', component: HomeComponent},
  {path: 'news', component: NewsComponent},
  {path: 'product', component: ProductComponent}
];
@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }
```

### 4: 测试配置，解释

打开浏览器输入`http://localhost:4200/home`  
后面的 / home 也是我在上面配置的一个路径，看是否能够显示 home 组件的内容  
![](https://img-blog.csdnimg.cn/20190709220758979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)  
从上图中看到这里红色部分就是 home 组件的 html 内容。路由配置成功。但是他是在什么地方显示出来的呢。我们打开 app.component.html 看到`<router-outlet></router-outlet>`  
_至于他是什么时候生成的，在你新建项目 Would you like to add Angular routing? (y/N)，你输入 y 即可。剩下的路由引入就是 Angualr 的事情了。_

> 可以简单把它理解为： 页面的占位符，动态加载，会被替换掉的。  
> 当点击 home、about、 dashboard 时，在导航栏的下方，  
> 会被对应的 XX.component.html 替换掉。 这就是单页面路由的原理。

这个地方解释的比较易懂：https://www.jianshu.com/p/d2e0223a337d  
但是我们不能总是通过手动改变 url 地址来跳转到相应的组件。所以接下来。。。。

### routerLink 配置动态路由

app.component.html

```
<h3>我是根组件app.component</h3><br>
<a [routerLink]="[ '/home' ]"  routerLinkActive="active">首页</a><br><br>
<a routerLink='/news' routerLinkActive="active">新闻</a><br><br>
<a [routerLink]="[ '/product' ]" routerLinkActive="active">商品页面</a><br>

<router-outlet></router-outlet>
```

这里面 routerLink 里面用到的 path 就是在 app-routing.module.ts 里配置的。当你点击首页时，首页组件会被替换到 `<router-outlet></router-outlet>`的位置。routerLinkActive 作用：给`<router-outlet></router-outlet>`显示的组件一个自定义的样式。所以下面当我点击**新闻**时候会出现下面的效果：  
![](https://img-blog.csdnimg.cn/20190709222336266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)

### 默认组件

一开始打开页面并没有点击那哪个组件的时候，下面没有显示任何组件的信息，是很不友好的，所以要配置一个默认显示的组件。  
在 app-routing.module.ts 加配置：

```
// 匹配不到的时候显示的组件
  {path: '**',  redirectTo : 'home'}
```

这样的话，刚进入页面就可以加载首页的组件。

N：路由传值以及 JS 跳转路由
================

新闻组件里面有几条新闻，希望通过点击新闻到新闻详情页查看该新闻详情。

### 0: 准备详情组件及新闻数据和页面

```
ng g component components/detail
```

然后在路由配置里面配置 `{path: 'detail', component: DetailComponent}`  
然后在新闻组件里面定义几条数据并展示  
![](https://img-blog.csdnimg.cn/20190709230256732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)

### 1: 路由的 get 传值：

##### 传值

![](https://img-blog.csdnimg.cn/20190709231952220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)

##### detail 接受传过来的值并展示

![](https://img-blog.csdnimg.cn/20190709232106931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)

##### get 路由传值效果

![](https://img-blog.csdnimg.cn/20190709232207118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)

### 2: 动态路由传值

##### 修改路由配置

![](https://img-blog.csdnimg.cn/20190709232715333.png)

##### 传值，接收

![](https://img-blog.csdnimg.cn/20190709234114237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)

##### 动态路由传值测试

![](https://img-blog.csdnimg.cn/20190709234151479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)

### 3:JS 路由跳转

前面讲的两个路由都是在页面上用户主动点击跳转的，那么当需要有业务逻辑跳转的时候就要用到 js 路由跳转。  
先新建一个组件商品详情页，上面已经创建了商品的组件`ng g component components/productContent`  
在 app-routing.module.ts 里配置组件路由

```
import { ProductContentComponent } from './components/product-content/product-content.component';

  {path: 'content/:pid', component: ProductContentComponent},
```

### 1: 普通路由，动态路由跳转

![](https://img-blog.csdnimg.cn/20190710001338788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)

### 2:get 传值 JS 跳转

先多引入一个 NavigationExtras，其实不引入跑起来也可以，应该是标准的问题吧。。

##### 代码

![](https://img-blog.csdnimg.cn/20190710002528111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)  
至于怎么接受数据，在之前的例子中已经提到了

##### 点击按钮后的效果

跳转成功，并且 url 后面的参数就是我传过去的。  
![](https://img-blog.csdnimg.cn/20190710002803575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)

O: 路由守卫
=======

路由守卫有几种, 可以参考 [[这个链接]](https://segmentfault.com/a/1190000010851032)  
我这里这讲其中的两种:**CanActivate,CanActivateChild**  
他们俩的**目的**是一样的: 就是在跳转到目标路由之前先判断是否符合设置的逻辑 (canActivate() 的返回值, 返回 true 就可以跳转到目标路由, 返回 false 则做其他自定义处理), 只不过 **CanActivateChild** 针对是所有子路由.

### 1: 创建公共服务类 ServeService

这个服务实现了 CanActivate ,CanActivateChild, 并重写 canActivate 和 canActivateChild 方法. 我这里的目的是如果用户信息不存在于 cookie 中, 则判断用户信息是否在缓存中, 两者都不在, 则跳转到登录页, 并且返回 false; 否则, 返回 true, 也就是跳转到目标路由.

```
import { Injectable } from '@angular/core';
import { CookieService } from 'ngx-cookie-service';
import { Router,CanActivate,CanActivateChild ,RouterStateSnapshot,ActivatedRouteSnapshot } from '@angular/router';

@Injectable()
export class ServeService  implements CanActivate ,CanActivateChild{
  //跳轉到目標路由前檢查有沒有登錄
  canActivate(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot,
  ): boolean {
    let cookieVal=this.cookieService.get("userName");
    let storages=this.get("userName");
    console.log("访问一次canActivate---cookieVal:"+cookieVal+"----storages:"+storages);
    if(cookieVal != null && cookieVal != ""){
      return true;
    }else if(storages != null && storages != ""){
      return true;
    }else{
      this.router.navigate(['login'],{ queryParams: { 'errorInfo': 'noAuth'}} );
      return false;
    }
  }

  canActivateChild(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot,
  ): boolean {
    return this.canActivate(route, state);
  }

  //保存到緩存
  set(key:string,value:any){
    localStorage.setItem(key,JSON.stringify(value));
  }
  //取緩存值
  get(key:string){
    return JSON.parse(localStorage.getItem(key));
  }
  //刪除緩存
  remove(key:string){
    localStorage.removeItem(key);
  }
  constructor(private router: Router,private cookieService: CookieService) {}
}
```

### 2: 路由配置

这里实际上配置哪些路由在跳转之前需要经过这个路由守卫, 雷士于 java 的 filter  
![](https://img-blog.csdnimg.cn/20190711165719640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)

### 3: 测试

##### cookie 和缓存中没值

![](https://img-blog.csdnimg.cn/20190711165949721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)

##### cookie 或者缓存中有值

![](https://img-blog.csdnimg.cn/20190711170117874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)

P: 创建模块
=======

```
ng g module routes/forcast-budget
```

![](https://img-blog.csdnimg.cn/b2c07749659541789ab5f7fc9b94fce8.png)  
然后在父路由里配置一下这个子路由  
![](https://img-blog.csdnimg.cn/e4ff2fb83ca74cf397eb154be0c8b507.png)  
然后其他增加服务和增加组件和上面的创建服务和组件类似

分页查询, 文件上传
==========

Angular 分页
----------

![](https://img-blog.csdnimg.cn/20190712131959751.png)  
先把分页代码贴上来

#### 1:pagination.component.html

```
<ul class="pagination">
  <li>
    <a (click)="changePage(0)">
      <i class="iconfont" title="首页">首页</i>
    </a>
  </li>
  <li [class.disabled]="currentPage < 1">
    <a (click)="goPrevious(currentPage)">
      <i class="iconfont" title="上一页"><</i>
    </a>
  </li>
  <li class="disabled" *ngIf="currentPage > 3">
    <a>...</a>
  </li>
  <li *ngIf="currentPage >= 3">
    <a (click)="changePage(currentPage-3)">{{currentPage-2}}</a>
  </li>
  <li *ngIf="currentPage >= 2">
    <a (click)="changePage(currentPage-2)">{{currentPage-1}}</a>
  </li>
  <li *ngIf="currentPage >= 1">
    <a (click)="changePage(currentPage-1)">{{currentPage}}</a>
  </li>
  <li class="active">
    <a (click)="changePage(currentPage)">{{currentPage+1}}</a>
  </li>
  <li *ngIf="currentPage <= totalPage-2">
    <a (click)="changePage(currentPage+1)">{{currentPage+2}}</a>
  </li>
  <li *ngIf="currentPage <= totalPage-3">
    <a (click)="changePage(currentPage+2)">{{currentPage+3}}</a>
  </li>``
  <li *ngIf="currentPage <= totalPage-4">
    <a (click)="changePage(currentPage+3)">{{currentPage+4}}</a>
  </li>
  <li class="disabled" *ngIf="currentPage < totalPage-4">
    <a>...</a>
  </li>
  <li [class.disabled]="currentPage > totalPage-2">
    <a (click)="goNext(currentPage)">
      <i class="iconfont" title="下一页">></i>
    </a>
  </li>
  <li>
    <a (click)="changePage(totalPage-1)">
      <i class="iconfont" title="末页">末页</i>
    </a>
  </li>
</ul>
```

#### 2:pagination.component.ts

```
import { Component, OnInit, EventEmitter, Input, Output } from '@angular/core';

/*
功能：分页组件
用法：
html：<hw-pagination [currentPage]="currentPage" [totalPage]="totalPage" (pageChange)="changePage($event)"> </hw-pagination>
ts：   private changePage(event){
        this.currentPage=event;
      }
注意：currentPage 从0开始
*/
@Component({
  selector: 'hw-pagination',
  templateUrl: './pagination.component.html',
  styleUrls: ['./pagination.component.css']
})
export class PaginationComponent implements OnInit {

  @Input() totalPage: number;
  @Input() currentPage: number;
  @Output() pageChange = new EventEmitter<number>();
  constructor() { }
  ngOnInit() {
  }

  changePage(pageNum) {
    this.pageChange.emit(pageNum);
  }

  goPrevious(pageNum) {
    if (pageNum >= 1) {
      this.changePage(pageNum - 1);
    }
  }

  goNext(pageNum) {
    if (pageNum <= this.totalPage - 2) {
      this.changePage(pageNum + 1);
    }
  }
}
```

#### 3:pagination.component.css

```
.pagination li {
  cursor: pointer;
}

.iconfont {
  color: #337ab7;
}

.pagination a {
  height: 34px;
}
```

#### 4: 使用之前

我这里自定义了一个 module, 在该 module 里都是对一些公共组件 (叫插件更贴切), 然后在 app.module.ts 里面就不用一个个引入这些插件, 直接 import 这个自定义的 module 就可以了.  
在被其他组件调用之前先要把这个分页组件对外暴露: 如下, 另外两个是**上传的组件和防止重复点击组件**

```
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { PaginationComponent } from './component/pagination/pagination.component';
import { DebounceClickDirective } from './directive/debounce-click.directive';
import { ErrorImgDirective } from './directive/error-img.directive';
import { FileUploadComponent } from './component/file-upload/file-upload.component';

@NgModule({
  imports: [
    CommonModule
  ],
  declarations: [PaginationComponent, DebounceClickDirective, ErrorImgDirective, FileUploadComponent],
  exports: [PaginationComponent, DebounceClickDirective,FileUploadComponent]
})
export class SharedModule { }
```

#### 5: 使用分页组件和防止重复点击组件

html:

```
<button (click)="getUser()"  >普通查詢列表</button>
<button hwDebounceClick (debounceClick)="getUser2()" [debounceTime]="300">防止重複提交查詢列表</button>
<br>
<hr>
<table class="usertable">
  <th>姓名</th>
  <th>AD</th>
  <th>email</th>
  <th>adress</th>
  <th>phone</th>
  <tr *ngFor="let item of userList; let i=index" >
    <td>{{item.name}}</td>
    <td>{{item.AD}}</td>
    <td>{{item.email}}</td>
    <td>{{item.adress}}</td>
    <td>{{item.phone}}</td>
  </tr>

</table>
<hw-pagination [currentPage]="currentPage" [totalPage]="totalPage" (pageChange)="changePage($event)"> </hw-pagination>
```

ts:

```
import { PaginationComponent } from './../../../shared/component/pagination/pagination.component';
import { Component, OnInit } from '@angular/core';
import { Router } from '@angular/router';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { CookieService } from 'ngx-cookie-service';
import * as $  from 'jquery';
@Component({
  selector: 'app-echarts',
  templateUrl: './echarts.component.html',
  styleUrls: ['./echarts.component.css']
})
export class EchartsComponent implements OnInit {
  public userList:any;
  constructor(private router: Router,public http: HttpClient,private cookieService: CookieService) { }
  currentPage:number=0;
  totalPage:number=1;
  ngOnInit() {
  }

  getUser(){
    console.log('当前页数'+(this.currentPage+1));
    let url = "http://localhost:8080/getMembers?currentPage="+(this.currentPage+1);
    const header = {headers: new HttpHeaders({'Content-Type': 'application/json'})};
    this.http.post(url,{},header).subscribe(re=>{
      this.totalPage=18;
      this.userList=re;
     console.log( this.userList);
    });
  }

  //防止短時間內重複提交
  getUser2(){
    console.log('当前页数'+(this.currentPage+1));
    let url = "http://localhost:8080/getMembers?currentPage="+(this.currentPage+1);
    const header = {headers: new HttpHeaders({'Content-Type': 'application/json'})};
    this.http.post(url,{},header).subscribe(re=>{
      this.totalPage=18;
      this.userList=re;
     console.log( this.userList);
    });
  }
  private changePage(event){
    this.currentPage=event;
    //这里注意一下方法调用的顺序
    this.getUser();
  }

}
```

css

```
.usertable{
    border: 1px solid black;
    width: 600px;
}
.usertable th,tr{
    height: 10px;
}
.usertable th,td{
    border: 1px solid black;
    text-align: center;
}
```

#### 6: 后台 java

假数据哈, 别介意

```
@RequestMapping(value = "/getMembers",method = RequestMethod.POST)
    public List getMembers(@RequestParam(name = "currentPage") int currentPage){
        System.out.println("当前页数:"+currentPage);
        List list=new ArrayList();
        for(int i=0;i<25;i++){
            Map<String,Object> map=new HashMap<String,Object>();
            map.put("name","kone"+(i+1));
            map.put("AD","R"+(i+2500));
            map.put("email",(i+1)+".mitac.com");
            map.put("adress","永和一村"+(i+45)+"棟");
            map.put("phone",1832618680+i);
            list.add(map);
        }
        return list;

    }
```

#### 7: 效果

![](https://img-blog.csdnimg.cn/20190712133405527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDUzNTg0,size_16,color_FFFFFF,t_70)

#### 8: 小结

这里面用到了 #Input 和 @Output, 父子组件的通信. [可以参考上一篇](https://blog.csdn.net/qq_39053584/article/details/93997318)

Angular 上传文件
------------

html:

```
<!-- 上传单个文件 -->
  <div>
  <input type="file" (change)="uploadFile($event)" />
  </div><br><br>
<p style="color: red">{{resultInfo}}</p>
```

ts

```
// post方式上传单个文件
  uploadFile(event) {
      let file: FormData = new FormData();
      let fileList: FileList = event.target.files;
      if (fileList.length > 0) {
          let file: File = fileList[0];
          let formData: FormData = new FormData();
          formData.append('value', file, file.name);
          let url = this.baseUrl + "/importExcel";
          const header = {headers: new HttpHeaders({'Accept':'application/json'})};
          this.http.post(url,formData,header).subscribe(re=>{
            this.resultInfo=re['msg'];
          });
      }
  }
```

这个比较简单, 贴出这个只是记录一下这个可能会是个坑

```
const header = {headers: new HttpHeaders({'Accept':'application/json'})};
```

问题处理记录:
=======

**1:Cannot find module ‘@angular-devkit/core’**  
(我再第一步就可以解決, 所以沒尝试重装 cli)  
https://blog.csdn.net/u011389297/article/details/80296444

缺点：
===

1：因为是单页面，不利于 SEO 优化  


