> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [blog.csdn.net](https://blog.csdn.net/Liukairui/article/details/118006761?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163574521516780271530668%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=163574521516780271530668&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-118006761.first_rank_v2_pc_rank_v29&utm_term=%E5%B0%9A%E7%A1%85%E8%B0%B7ES6%E7%AC%94%E8%AE%B0&spm=1018.2226.3001.4187)

**ES6-ES12**

ES 介绍
-----

ES 就是 ECMAScript 简称，JS 就是 ES 的一个实现，这里 ECMA(欧洲计算机制造商学会) 每年发布一个 ES 新版本，2020 年到了 ES11，前置内容: JS,Ajax,[Promise](https://so.csdn.net/so/search?q=Promise&spm=1001.2101.3001.7020)

**为什么从 ES6 开始**: 变动多，有里程碑意义，新增语法特性

**ES 兼容性**：[查询网站](https://caniuse.com/es6)，即使不兼容我们也可以通过编译器编译成 ES5

[ES6](https://so.csdn.net/so/search?q=ES6&spm=1001.2101.3001.7020) 新特性
----------------------------------------------------------------------

### eval 函数 (ES3 函数补充)

`eval()`函数可计算某个字符串，并执行其中的的 JavaScript 代码。

*   语法: eval(string)  
    string: 要计算的字符串，其中含有要计算的 JavaScript 表达式或要执行的语句。
*   返回值  
    通过计算 string 得到的值（如果有的话）。
*   说明  
    该方法只接受原始字符串作为参数，如果 string 参数不是原始字符串，那么该方法将不作任何改变地返回。因此请不要为 `eval()` 函数传递 String 对象来作为参数。
*   如果试图覆盖 eval 属性或把 eval() 方法赋予另一个属性，并通过该属性调用它，则 ECMAScript 实现允许抛出一个 EvalError 异常。
*   抛出  
    如果参数中没有合法的表达式和语句，则抛出 SyntaxError 异常。如果非法调用 eval()，则抛出 EvalError 异常。如果传递给 eval() 的 Javascript 代码生成了一个异常，eval() 将把该异常传递给调用者。
*   虽然 eval() 的功能非常强大，但在实际使用中用到它的情况并不多。不同浏览器不同版本对 eval 处理有差异

**实例**

```
eval("x=10;y=20;document.write(x*y)")
console.log(eval("2+2"))
var x=10
console.log(eval(x+17))
```

输出

*   作用域
    
    ```
    var x = 1;
    (function () {
        eval('var x = 123;');
        console.log("I",x)
    })();
    console.log(x);
    ```
    
    和
    
    ```
    var x = 1;
    (function () {
        window.eval('var x = 123;');
        console.log("I",x)
    })();
    console.log(x);
    ```
    
    在 ES<=8，得到的是
    
    ```
    I 123
    I 123
    ```
    
    在 ES>8 得到的是
    
    ```
    I 123
    I 123
    ```
    
    在 ES8 - 下 eval 是函数作用域，在 ES8 + 下 eval 的作用域取决于调用者

### let 关键字

*   与`var`的级别用法一样
*   `let`不可以重复声明，但是`var`可以
    
    ```
    var varIns = "A";
    var varIns = "B"; // 合法
    let letIns = "A";
    let letIns = "B"; // 不合法
    ```
    
*   `let`具有块级作用域，`var`没有块作用域，JS 的作用域有
    *   全局作用域 (例如`a=1`，那么 a 就是 window 的成员)
    *   函数作用域 (例如在函数中`var a=1`, 那么出了函数 a 就没了)
    *   eval 作用域
    *   块作用域 (例如 {a=1},if(){},while(){}…, 那么在括号外面 a 就不可用)
*   `let`不存在变量提升，例如
    
    ```
    console.log(a);       // 输出undefined
    var a=1;
    console.log(a);       // 输出1
    
    console.log(b);       // 报错
    let b=1;
    console.log(b);
    ```
    
*   `let`不影响作用域链  
    虽然是块级作用域，但是不影响如果函数内部没有变量会自动往外找

**实例**

在以前写代码的时候我们遇到过这个问题

```
// 我有5个button
var btns = document.querySelectorAll("button");
for(var i = 0;i < btns.length;i++){
    btns[i].onclick = function(){
        console.log(i);
    }
}
```

这时候不管点哪个都显示 5, 这是因为 onclick 里面没有 i, 于是闭包传输了 i, 这个 i 是外面的 i,i 在变化，到点击的时候相当于是走完了

```
{var i=0} //第1个循环
{var i=1} //第2个循环
{var i=2} //第3个循环
{var i=3} //第4个循环
{var i=4} //第5个循环
```

这个时候 i 就是 5，因为 i 是 for 的块级作用域内部变量，var 没有块级作用域，第二个循环的修改会影响第一个循环的 i

我们有两个修改方法

增加参数

```
var btns = document.querySelectorAll("button");
for(var i = 0;i < btns.length;i++){
    btns[i].idx = i;
    btns[i].onclick = function(){
        console.log(this.idx);
    }
}
```

修改为 let

```
// 我有5个button
var btns = document.querySelectorAll("button");
for(let i = 0;i < btns.length;i++){
    btns[i].onclick = function(){
        console.log(i);
    }
}
```

相当于执行了

```
{let i=0} //第1个循环
{let i=1} //第2个循环
{let i=2} //第3个循环
{let i=3} //第4个循环
{let i=4} //第5个循环
```

let 有块级作用域，第二个循环的修改不会影响第一个循环的 i=1

### const 关键字

*   格式于 let 一样
*   必须赋初值
*   建议大写
*   不能修改
*   有块级作用域
*   常量指向数组 / 对象的修改不算修改，因为 const 对象指向的地址没有变

### 变量解构赋值

可以按照一定模式从数组 / 对象提取值，对变量进行赋值

*   对数组进行解构`[...]=Array`，就是找对应元素分别对应数组，例如
    
    ```
    let [a,b,c,d]=[111,222,333,"789"];
    console.log(a);
    console.log(b);
    console.log(c);
    console.log(d);
    ```
    
    不是很常用
    
*   可以对对象进行解构`{...}=Object`, 要求变量名一一对应，例如
    
    ```
    let t={
        a:111,
        b:222,
        d:333,
        c:function(){console.log("OK")}
    }
    let {a,b,c,d}=t;
    console.log(a);
    console.log(b);
    console.log(c);
    c();
    console.log(d);
    d();              // Error
    ```
    
    解构一般用于提取方法, 例如我之前要写`t.c()`就可以简写成`c()`了
    
*   解构时候如果数目不同 / 不匹配时，会尽量匹配，例如
    
    ```
    let [a,b] = [1,2,3]  // a=1 b=2
    let [a,b,c,d] = [1,2,3]  // a=1 b=2 c=3 d=undefined
    let t={
        x:111,
        y:222,
        z:333,
        w:function(){console.log("OK")}
    }
    let {x,y} = t;      // x=111 y=222
    let {z,w,s} = t;    // z=333 w=[function] s=undefined
    ```
    
*   解构支持默认值  
    JS 确认某个参数要使用默认值是这个参数 ===undefined
    
    ```
    let [m1,m2="S"] = ["A"]   // m1="A" m2="S"
    let [n1,n2="S"] = ["A",undefined]   // n1="A" n2="S"
    let [p1,p2="S"] = ["A",null]   // p1="A" p2=null
    ```
    
*   字符串的解构赋值  
    将字符串转化为数组
    
    ```
    let [a,b,c] = "Liu" // a="L" b="i" c="u"
    ```
    
*   数值与布尔值解构
    
    ```
    let {toString: s}=123;
    console.log(s===Number.prototype.toString)
    let {toString: r}=true;
    console.log(r===Boolean.prototype.toString)
    ```
    
    都是 true
    
*   函数参数解构
    
    ```
    function foo([a,b]){
      console.log(a,b); // 1,2
    }
    foo([1,2])
    
    function foo2({a=0,b=0}={}){        // 无参时默认{} a,b也有默认值
    //function foo2({a,b}={a=0,b=0}){   // 注意，这两种方法出的结果不同    
      console.log(a,b);
    }
    foo2({a:1,b:2})         // 1,2
    foo2({a:1})             // 1,0
    foo2({a:undefined,b:2}) // 0,2
    foo2()                  // 0,0
    ```
    
*   用处
    
    *   交换值`[a,b]=[b,a]`
    *   接受函数返回对象 / 数组
    *   函数参数定义
    *   函数参数默认值
    *   加载模块
        
        ```
        const { SourceMapConsumer, SourceNode} = require("source-map")
        ```
        
    *   获取 map 值
        
        ```
        let map = new Map();
        map.set("a","A")
        map.set("b","B")
        
        // 获取键值
        for (let [key,value] of map) {
          // ...
        }   
        
        // 获取键名
        for (let [key] of map) {
          // ...
        }   
        
        // 获取键值
        for (let [value] of map) {
          // ...
        }
        ```
    
*   补充 for 的遍历
    
    *   `for in` 便历出来的是属性
    *   `for of` 遍历的是 value
    *   手动给对象添加属性后, for in 是可以将新添加的属性遍历出来 但是 for of 不行
    *   `for in` 的属性是使用 [] 不可以使用 “.” eg: data[‘index’] instead of data.index

### 模板字符串

模板字符串使用` `` `声明，支持

*   在内容中出现换行 例如
    
    ```
    let a = '123\n  456\n   789';
    console.log(a);
    let b = `123
       789`;
    console.log(b);
    let c = '123
       789';
    console.log(c);
    ```
    
    输出分别是
    
    ```
    报错
    ```
    
*   支持变量拼接，使用 ${}
    
    ```
    let name = "Liu";
    let spk1 = `I'm `+name+`, Hello`
    let spk2 = `I'm ${name}, Hello`
    console.log(spk1)
    console.log(spk2)
    ```
    

### 简化对象写法

可以在 {} 中直接写对象，例如

```
let aaa = "aaa"
let bbb = "bbb"
console.log({aaa,bbb})
console.log({aaa: "aaa", bbb: "bbb"})
console.log({aaa, bbb, foo(){console.log("OK")}})
console.log({aaa: "aaa", bbb: "bbb", foo:function(){console.log("OK")}})
```

结果是

```
{aaa: "aaa", bbb: "bbb"}
{aaa: "aaa", bbb: "bbb"}
{aaa: "aaa", bbb: "bbb", foo: ƒ}
{aaa: "aaa", bbb: "bbb", foo: ƒ}
```

这里要简写的是变量, 不能是常量，例如我想构造`{"A":"A"}`不能写`{"A"}`

### [箭头函数](https://so.csdn.net/so/search?q=%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020)

将`function(a,b)=>{//code}`简写为`(a,b)=>{//code}`

*   this 是静态的，始终指向函数声明时所在**作用域**下的 this(call,apply 修改对 他无效)，而 funcion 是 this 指向调用者
    
    ```
    S.prototype.work1=function(){
        setTimeout(function(){console.log(this)},1000)
    }
    
    S.prototype.work2=function(){
        setTimeout(()=>{console.log(this)},1000)
    }
    
    S.prototype.work3=()=>{
        setTimeout(()=>{console.log(this)},1000)
    }
    
    let s=new S();
    s.age = 12;
    s.work1();
    s.work2();
    s.work3();
    ```
    
    输出
    
    ```
    window
    s对象
    window
    ```
    
*   不能作为构造函数实例化对象，因为 this 不能指向对象，会报错 XX 不是一个构造函数
*   不能使用 arguments 变量
    
    ```
    function work1(){console.log(arguments)}
    function work2(...arg){console.log(arg)}
    work3=()=>{console.log(arguments)}
    work4=(...arg)=>{console.log(arg)}
    work1(1,2,3,4)    // 输出Arguments变量
    work2(1,2,3,4)    // 输出数组
    work4(1,2,3,4)    // 输出数组
    work3(1,2,3,4)    // 报错arguments是undefined
    ```
    
*   箭头函数还可以简写
    *   当只有一个形参的时候可以把`(a)=>{// code}`简写成`a=>{// code}`
    *   当代码体只有一条语句的时候`()=>{// onecode}`简写成`()=>// onecode`, 同时不能写 return, 此时语句的返回结果就是返回值，例如`(a)=>{return a*a}`简写为`a=>a*a`
*   特例，我想简写返回对象`x => { foo: x }`会报错，换成`x => ({ foo: x })`

**实例** 不适合与 this 有关的操作，例如 dom 的回调

```
let [btn1,btn2] = document.querySelectorAll("button");
btn1.myflag=true;
btn1.onclick=function(){
  setTimeout(function(){
    console.log(this.myflag);
  },1000)
}
btn2.myflag=true;
btn2.onclick=function(){
  setTimeout(()=>{
    console.log(this.myflag);
  },1000)
}
```

点击第一个按钮是 undefined，第二个是 true

获取所有奇数

```
let s = [1,4,5,6,7,8]
console.log(s.filter(i=>i%2))
```

### 函数默认参数

*   略
*   与解构赋值结合
    
    ```
    function foo({url=127,port=22}={}){
      console.log(url,port)
    }
    foo({url:128})
    foo({port:23})
    foo({lalala:128})
    foo()
    ```
    

### REST 参数

对于 function 定义的函数可以使用`arguments`获取参数列表，`arguments`是一个伪数组，没有 forEach 等函数，我们可以使用 REST 参数解决, 写法是… 变量，

```
function foo(...args){
  console.log(args)
}
foo(1,2,3,4);   // 结果是[1,2,3,4]
```

与 C 语言的… 一样，我们也可以指定一部分，但是… 必须放末尾

```
function foo(x,y,...args){
  console.log(args)
}
foo(1,2,3,4);   // 结果是[3,4]
```

### …Spread 扩展[运算符](https://so.csdn.net/so/search?q=%E8%BF%90%E7%AE%97%E7%AC%A6&spm=1001.2101.3001.7020)

与 REST 的… 标识一样，作用不同, rest 是放在形参的位置，扩展运算符是放在调用实参的位置，用来将数组分开 (类似于解构数组)

```
function foo(){
    console.log(arguments)
}
foo(...[1,2,3])   //Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]
```

扩展运算符只能用在函数调用时候，但是也包括如写用法

```
// 1. 数组的合并
let ary = [...[1,2,3],...[4,5,6],...[7,8,9]]
// [1,2,3,4,5,6,7,8,9]

// 2. 数组的克隆
let aty_cp = [...ary]
// 当然这是个浅拷贝

// 3. 伪数组的转换
function foo(){
  let agms = [...arguments]
  console.log(agms)
}
foo(1,2,3,4,5)
```

`...`实际上是个语法糖

### [Symbol](https://so.csdn.net/so/search?q=Symbol&spm=1001.2101.3001.7020) 数据类型

*   Symbol 是 ES6 引入的一种新的数据类型
*   用来表示独一无二的值
*   他是一种类似于字符串的值，保证值是唯一的
*   Symbol 值不能参与任何一种运算，外部也看不到 Symbol 的值是多少, 只能知道分别定义两个 Symbol 一定是不同的

**创建 Symbol**

```
let s = Symbol()    // 不用写new 因为是js的默认数据类型
console.log(s,typeof s)     // Symbol() symbol
```

我们无法知道 Symbol 的值，js 保证内部实现独一无二

我们还可以为 Symbol 传入一个注释

```
let s1 = Symbol("Liu");
let s2 = Symbol("Liu");
console.log(s1===s2)     // false
```

但是相同的注释不是生成相同的结果，这个功能一般用于调试使用, 例如想为对象加入一个 debug 熟悉就可以`Obj[Symbol(debug)]="OK"`，方便我们删除, **在 ES10 中会有新方法对注释进行利用**

我们可以像使用 hash 一样为相同的内容生成相同的 Symbol

```
let s1 = Symbol.for("Liu");
let s2 = Symbol.for("Liu");
console.log(s1===s2)     // true
```

**Symbol 的作用**[原文](https://blog.csdn.net/lu92649264/article/details/113589524)

Symbol 的作用非常的专一，换句话说其设计出来就只有一个目的——作为对象属性的唯一标识符，防止对象属性冲突发生。

举个例子，你看上了公司前来的前台妹纸，想了解关于她的更多信息，于是就询问 Hr 同事，扫地阿姨，于是得到类似这样信息：

```
let info1 = {
    name: '婷婷',
    age: 24,
    job: '公司前台',
    description: '平时喜欢做做瑜伽，人家有男朋友，你别指望了'
}
let info2 = {
    description: '这小姑娘挺好的，挺热情的，嘿嘿嘿……'
}
```

显然，你需要对这两个数据进行汇总，结果，就会发现，描述都用了同一个对象属性 description，于是整合的时候，就容器冲突，覆盖，导致 “人家有男朋友” 这么重要的信息都没注意到。

但是，如果要是 Symbol，则完全就不要担心这个问题了：

```
let info1 = {
    name: '婷婷',
    age: 24,
    job: '公司前台',
    [Symbol('description')]: '平时喜欢做做瑜伽，人家有男朋友，你别指望了'
}
let info2 = {
    [Symbol('description')]: '这小姑娘挺好的，挺热情的，嘿嘿嘿……'
}
```

此时，我们对 info1, info2 对象进行复制，如下：

```
let target = {};
Object.assign(target, info1, info2);
```

此时 target 对象如下所示：

```
{name: "婷婷", age: 24, job: "公司前台", Symbol(description): "平时喜欢做做瑜伽，人家有男朋友，你别指望了", Symbol(description): "这小姑娘挺好的，挺热情的，嘿嘿嘿……"}
```

**Symbol 内置值**  
作为数据类型，Symbol 不能像 String 一样直接直接使用，而是像声明一个对象一样的使用，这是因为 Symbol 是一个函数对象，具有成员函数，有

*   `Symbol.hasInstance()`: 判断是否是 Symbol
*   `Symbol.isConcatSpreadable`: 决定是否可以 Spread, 例如
    
    ```
    let a = [1,2,3];
    let b = [4,5,6];
    let c = [...a,...b];
    let d = a.concat(b)
    b[Symbol.isConcatSpreadable] = false;
    let e = [...a,...b];
    let f = a.concat(b)
    console.log(c,d,e,f)
    ```
    
    结果
    
    ```
    [ 1, 2, 3, 4, 5, 6 ] 
    [ 1, 2, 3, 4, 5, 6 ] 
    [ 1, 2, 3, 4, 5, 6 ] 
    [ 1, 2, 3, [ 4, 5, 6, [Symbol(Symbol.isConcatSpreadable)]: false ] ]
    ```
    
*   还有一些属性是当这个 Symbol 作为一个函数的参数自动执行的方法，见[此文章](https://www.vxzsk.com/1434.html)

**其他 Symbol 相关**

*   Symbol 与 for…in 迭代  
    Symbols 在 for…in 迭代中不可枚举，如果想要达到效果，借助 Object.getOwnPropertySymbols(obj) 这个方法。

```
var obj = {};

obj[Symbol("a")] = "a";
obj[Symbol.for("b")] = "b";
obj["c"] = "c";
obj.d = "d";

for (var i in obj) {
   console.log(i);   // 输出 "c" 和 "d"
}
```

*   Symbol 与 JSON.stringify()  
    当使用 JSON.strIngify() 时以 symbol 值作为键的属性会被完全忽略，例如：
    
    ```
    JSON.stringify({[Symbol("foo")]: "foo"});    // '{}'
    ```
    
*   Symbol 包装器对象作为属性的键  
    围绕原始数据类型创建一个显式包装器对象从 ECMAScript 6 开始不再被支持，所以 new Symbol() 会报错，然而，现有的原始包装器对象，如 new Boolean、new String 以及 new Number 因为遗留原因仍可被创建。
    
    此时，如果我们想创建一个 Symbol 包装器对象 (Symbol wrapper object)，你可以使用 Object() 函数：
    
    ```
    var sym = Symbol("foo");
    typeof sym;     // "symbol"
    var symObj = Object(sym);
    typeof symObj;  // "object"
    ```
    
    当一个 Symbol 包装器对象作为一个属性的键时，这个对象将被强制转换为它包装过的 symbol 值：
    
    ```
    var sym = Symbol("foo");
    var obj = {[sym]: 1};
    obj[sym];            // 1
    obj[Object(sym)];    // 还是1
    ```
    

**总结 JS 数据类型**: UOSNB

*   U: undefiend
*   O: Object
*   S: String Symbol
*   N: Null Number
*   B: Boolean

### 迭代器

迭代器是一种接口，各种数据结构只要在定义的时候定义了 Iterator 接口 (就是对象就具有 Iterator 成员变量) 就可以完成迭代操作

*   ES6 加入了新的遍历方式 `for-of` , 调用 Iterator 接口对对象进行遍历
*   ES6 原生具备 Iterator 的对象有
    *   Array
    *   Arguments
    *   Set
    *   Map
    *   String
    *   TypedArray
    *   NodeList
*   Iterator 的使用方法与 C++ 的迭代器相似，创建的时候迭代器变量获得对象，在迭代器. next() 后, next 函数返回一个指向数据结构的首地址值，使用 next 进行指针的移动获得值，不断调用 next 达到数据结构的

**查看使用预定义接口**

以 Array 为例, Iterator 保存在`Array.prototype.Symbol(Symbol.iterator)`，也就是实例的`[].__proto__.Symbol(Symbol.iterator)`, 他对应的值是一个对象

使用`next()`

```
let a = ['A','B','C'];
let iterator = a[Symbol.iterator]();
console.log(iterator)         // 这里的iterator是一个包含next()的对象
console.log(iterator.next())  // 这里的iterator不变，next()返回的是对象的0地址等内容
console.log(iterator.next())  // 这里的iterator不变，next()返回的是对象的1地址等内容
console.log(iterator.next())  // 这里的iterator不变，next()返回的是对象的2地址等内容
console.log(iterator.next())  // 这里的iterator不变，next()返回的是无内容
```

结果

```
{value: "A", done: false}     // 返回值是一个对象，包含value和done表示是否结束迭代
{value: "B", done: false}
{value: "C", done: false}
{value: undefined, done: true}    // 遍历结束后设置done=true
```

使用`for-of`

```
let a = ['A','B','C'];
for(let i of a)
    console.log(i)          // i 保存的是Value

for(let i in a)
    console.log(i)          // i 保存的是Key
```

在这里也见识到到 Symbol 的作用, 他创建了 Array 的一个独一无二的属性

**自定义迭代器**

为类自定义一个迭代器，我们实现一个 FakeArray 类，他包含了姓名和一个数组，每次迭代返回`姓名@数组元素`

```
function FakeArray(name,...arg){
  this.name = name;
  this.data = [];
  arg.forEach((d,i)=>
      this.data.push(d)
  )
}

/**
 * let fa = new FakeArray("Liu","H","A","P","P","Y")
 * 我们的需求是for(d of fk)遍历fk.data的元素
 * 不直接使用`fk.data.forEach()`的原因是1. 不OOP思想了 2. data不安全了
 */

FakeArray.prototype[Symbol.iterator]=function(){  // 定义一个迭代器的构造函数
  let idx = 0;          // 一部分自定义代码
  return {              // 迭代器应该是一个有next函数的对象
    next: ()=>{         // 每次执行next函数 包含value done, 用箭头函数使得可以读到idx
      return {value:this.name+"@"+this.data[idx],done:idx++===this.data.length}
    }
  }
}

let fa = new FakeArray("Liu","H","A","P","P","Y");
for(d of fa){
  console.log(d)
}
```

为对象自定义一个迭代器，我们实现一个 fa 对象，他包含了姓名和一个数组，每次迭代返回`姓名@数组元素`

```
let fa = {
  name : "Liu",
  data : [..."happy"],
  // [Symbol.iterator]:function(){
  [Symbol.iterator](){        // 进行了简写，等同于上面注释的代码
    let idx = 0;
    return {
      next: ()=>{
        return {value:this.name+"@"+this.data[idx],done:idx++===this.data.length}
      }
    }
  }
}

for(d of fa){
    console.log(d)
}
```

### 生成器

生成器是一个函数，是一个 ES6 异步编程解决方案, 之前我们异步编程使用的是回调函数，但是容易形成回调地狱

**定义**: 生成器函数与就是在普通函数声明前面加入了`*`, 例如

```
function * gen(){
  console.log("hi");
  return "GEN OK"
}
```

我们可以将函数的结果赋值给变量，函数不会立刻运行，变量的值是一个迭代器。函数运行，当且仅当变量执行了 next(), 这个时候变量的值还是迭代器，返回值要另行接受，例如

```
function * gen(){
  console.log("hi");
  return "GEN OK"
}

let p = gen();
console.log(p);     // p是gen {<suspended>} 是一个迭代器
let q = p.next()    // 执行next 输出hi 
console.log(p,q);   // p是gen {<closed>} 迭代器 q是迭代器结果{value: "GEN OK", done: true}
```

注意，gen 函数可以使用 yield 进行分割,

*   yield 是 ES6 的新关键字，使生成器函数执行暂停，yield 关键字后面的表达式的值返回给生成器的调用者。它可以被认为是一个基于生成器的版本的 return 关键字。
*   yield 关键字实际返回一个 IteratorResult（迭代器）对象，它有两个属性，value 和 done，分别代表返回值和是否完成。
*   yield 无法单独工作，需要配合 generator(生成器) 的其他函数，如 next，懒汉式操作，展现强大的主动控制特性。

```
function * gen(){               
  // ====函数第1部分====
  console.log("Part 1");
  yield "P1"                  // == 返回"P1" 不得用return否则后面代码都无效了
  // ====函数第2部分====
  console.log("Part 2");
  yield "P2"                  // == 返回"P2" 不得用return否则后面代码都无效了
  // ====函数第3部分====
  console.log("Part 3");
  yield "P3"                  // == 返回"P3" 不得用return否则后面代码都无效了
  // ====函数第4部分====
  console.log("Part 4");
  yield "P4"                  // == 返回"P4" 不得用return否则后面代码都无效了
  // ====函数第5部分====
  return "AllEnd"             // == 返回"AllEnd" 不得用yield会新开一个部分
}

let f = gen();

console.log(f.next())         // { value: 'P1', done: false }
console.log(f.next())         // { value: 'P2', done: false }
console.log(f.next())         // { value: 'P3', done: false }
console.log(f.next())         // { value: 'P4', done: false }
console.log(f.next())         // { value: 'AllEnd', done: true }
console.log(f.next())         // { value: undefined, done: true }
```

由于生成器是一个迭代器对象，我们也可以这么写

```
function * gen(){               
    // ====函数第1部分====
    console.log("Part 1");
    yield "P1"                  // == 返回"P1" 不得用return否则后面代码都无效了
    // ====函数第2部分====
    console.log("Part 2");
    yield "P2"                  // == 返回"P2" 不得用return否则后面代码都无效了
    // ====函数第3部分====
    console.log("Part 3");
    yield "P3"                  // == 返回"P3" 不得用return否则后面代码都无效了
    // ====函数第4部分====
    console.log("Part 4");
    yield "P4"                  // == 返回"P4" 不得用return否则后面代码都无效了
    // ====函数第5部分====
    return "AllEnd"             // == 返回"AllEnd" 不得用yield会新开一个部分
};

for(let d of gen()){
    console.log(d)
}
// Part 1
// P1
// Part 2
// P2
// Part 3
// P3
// Part 4
// P4
// 没有AllEnd,因为最后一次没用yield
```

**yield 参数传递**

如果想给某个部分的函数传递参数可以把参数写在 next()，yield 会获得返回值，例如

```
function * gen(a){
    console.log(a)
    let b = yield "===PART B==="
    console.log(b)
    let c = yield "===PART C==="
    console.log(c)
    let d = yield "===PART D==="
    console.log(d)
}

let it = gen(5);
console.log(it.next(4))
console.log(it.next(3))
console.log(it.next(2))
console.log(it.next(1))
console.log(it.next(0))     // over bound
```

**使用生成器避免回调地狱, 实现异步操作 1**

需求是 1-5s, 每 1s 输出一个数字，使用回调函数的写法是

```
setTimeout(()=>{
    console.log(1)
    setTimeout(()=>{
        console.log(2)
        setTimeout(()=>{
            console.log(3)
            setTimeout(()=>{
                console.log(4)
                setTimeout(()=>{
                    console.log(5)
                },1000)
            },1000)
        },1000)
    },1000)
},1000)
```

形成回调地狱，可以进行代码的扁平化

```
function * gen(){
    setTimeout(()=>{
        console.log(1);
        it.next()           // 输出结束之后再调用下一部分
    },1000)
    yield "P2"
    setTimeout(()=>{
        console.log(2);
        it.next()
    },1000)
    yield "P3"
    setTimeout(()=>{
        console.log(3);
        it.next()
    },1000)
    yield "P4"
    setTimeout(()=>{
        console.log(4);
        it.next()
    },1000)
    yield "P5"
    setTimeout(()=>{
        console.log(5);
        it.next()
    },1000)
}

let it = gen();
it.next();
```

我们的需求变成五秒每秒输出一个前一个数 + 5 的数

```
function * gen(p1){
    setTimeout(()=>{
        console.log(p1+5);
        it.next(p1+5)
    },1000)
    let p2 = yield "P2"
    setTimeout(()=>{
        console.log(p2+5);
        it.next(p2+5)
    },1000)
    let p3 = yield "P3"
    setTimeout(()=>{
        console.log(p3+5);
        it.next(p3+5)
    },1000)
    let p4 = yield "P4"
    setTimeout(()=>{
        console.log(p4+5);
        it.next(p4+5)
    },1000)
    let p5 = yield "P5"
    setTimeout(()=>{
        console.log(p5+5);
        it.next(p5+5)
    },1000)
}

let it = gen(666);      // 注意在这里传参
it.next();
```

对于流式工作我们可以这么写

```
function * gen(p1){
    setTimeout(()=>{
        console.log("do work 1");
    },1000)
    yield "P1 OK"
    setTimeout(()=>{
        console.log("do work 2");
    },1000)
    yield "P2 ER"
    setTimeout(()=>{
        console.log("do work 3");
    },1000)
    yield "P3 OK"
    setTimeout(()=>{
        console.log("do work 4");
    },1000)
    yield "P4 OK"
    setTimeout(()=>{
        console.log("do work 5");
    },1000)
    yield "ALL END"
}

let v = [];
let it = gen();      // 注意在这里传参
for(i of it){        // 当然，我们可以手动next方便传参 
    v.push(i)
}
console.log(v)
```

结果是

```
[ 'P1 OK', 'P2 ER', 'P3 OK', 'P4 OK', 'ALL END' ]
do work 1
do work 2
do work 3
do work 4
do work 5
```

*   生成器可以与 Promise 结合大大简化代码
*   yield 是参考 python 的语法，在前端中用处不大，在后端中，就显得比较重要了，因为其优越的可控性，可是极大的提升线程的效率。

### Promise

略，见 Promise 专门内容

**将生成器与 Promise 结合**[来源](https://www.kanzhun.com/jiaocheng/148059.html)

结合生成器（以及生成器暂停和恢复执行的能力）和 promise，来实现更加优雅的异步代码。

```
try{
  const ninjas = syncGetJSON('data/ninja.json');
  const missions = syncGetJSON(ninjas[0].missionsUrl);
  const missionDetails = syncGetJSON(missions[0].detailsUrl);
  //Study the mission description
} catch (e) {
  //Oh no,we were not able to get the mission details
}
```

尽管这段代码对于简化错误处理很方便，但 UI 被阻塞了，用户不希望看到这个结果。则可以使用生成器和 promise 结合。从生成器中让渡后会挂起执行而不会发生阻塞。而且仅需调用生成器迭代器的 next 方法就可以唤醒生成器并继续执行。而 promise 在未来触发某种条件的情况下让我们得到它事先允诺的值，而且当错误发生后也会执行相应的回调函数。

这个方法将要以如下方式结合生成器和 promise。

把异步任务放入一个生成器中，然后执行生成器函数。所以生成器执行的时候，我们会将执行权让渡给生成器，从而不会导致阻塞。过一会儿，当承若被兑现，我们会继续通过迭代器的 next 函数执行生成器。只要有需要就可以重复这个过程。

```
console.log('-------------将promise和生成器结合---------');
//返回异步结果的函数在等待异步结果返回时应当能够暂停，注意function*，使用生成器
async(function* () {
  try{
    //对每个任务均执行yield
    const ninjas = yield getJSON('data/ninjas.json');
    const missions = yield getJSON(ninjas[0].missionsUrl);
    const missionDescription = yield getJSON(missions[0].detailsUrl);
    //Study the mission description
  } catch (e) {
    //依旧可以使用标准的语言结构，诸如try-catch语句或循环语句
    //Oh no,we were not able to get the mission details
  }
});

//定义一个辅助函数，用于对我们定义的生成器执行操作
function async(generator) {
  //创建 一个迭代器，进而我们可以控制生成器
  var iterator = generator();

  //定义函数handle，用于对生成器产生的每个值进行处理。
  function handle(iteratorResult) {
    //当生成器没有更多结果返回时停止执行。
    if (iteratorResult.done) {
      return;
    }

    const iteratorValue = iteratorResult.value;
    //如果生成的值是一个promise，则对其注册成功和失败的回调。这是异步处理的部分。如果promise成功返回，则恢复生成器的执行并传入promise的返回结果。如果遇到错误，则生成器抛出异常。
    if (iteratorValue instanceof Promise) {
      iteratorValue.then(res =>{
        handle(iterator.next(res));
      }).catch(err =>{
        iterator.throw(err);
      });
    }
  }
 
  //重启生成器的执行
  try{
    handle(iterator.next());
  } catch (e) {
    iterator.throw(e);
  }
}
```

[async](https://so.csdn.net/so/search?q=async&spm=1001.2101.3001.7020) 函数内，我们声明了一个处理函数用于处理从生成器中返回的值——迭代器的一次 “迭代”。如果生成器的结果是一个被成功兑现的承若，我们就是用迭代器的 next 方法把承诺的值返回给生成器并恢复执行。如果出现错误，承若被违背，我们就使用迭代器的 throw 方法抛出一个异常。直到生成器完成前，一直重复这几个操作。

注意：

这只是一个粗略的草稿，一个最小化的代码应该把生成器和 promise 结合在一起。不推荐生产环境下出现这些代码。

现在仔细看看这个生成器，在第一次调用迭代器的 next 方法后，生成器执行第一次 getJSON(‘data/ninjas.json’) 调用。此次调用创建了一个 promise，该 promise 会包含需要的信息。但是这个值是异步获取的，所以我们完全不知道浏览器会花多少时间来获取它。但我们明白一件事，我们不希望在等待中阻塞应用的执行。所以对于这个原因，在执行的这一刻，生成器让渡了控制权，生成器暂停，并把控制流还给了回调函数的执行。由于让渡的值是一个 promise 对象 getJSON，在这个回调函数中，通过使用 promise 的 then 和 catch 方法，我们注册了一个 success 和一个 error 回调函数，从而继续了函数的执行。当浏览器接收到了响应（可能是成功的响应，也可能是失败的响应），promise 的两个回调函数之一则被调用了。如果 promise 被成功解决，则会执行 success 回调函数，随之而来的是迭代器 next 方法的调用，用于向生成器请求新的值，从而向生成器请求新值，从而生成器从挂起状态恢复，并把得到的值回传给回调函数。这意味着，程序又重新进入到生成器函数体内，当第一次执行 yield 表达式后，得到的值变成从服务器端获取的信息。

下一行代码的生成器函数中，我们使用获取到的数据 ninjas[0].missionsUrl 来发起新的 geJSON 请求，从而创建一个新的 promise 对象，最后返回最新的数据。我们依然不知道这个异步任务会执行多久，所以我们再一次让渡了这次执行，并重复这个过程。只要生成器中有异步任务，这个过程就会重新执行一次。

这个例子有一点不同，但它结合了许多知识点：

*   函数是第一类对象——我们向 async 函数了一个参数，该参数也是函数。
*   生成器函数——用它的特性来挂起和恢复执行。
*   pomise——帮我们处理异步代码。
*   回调函数——在 promise 对象上注册成功和失败的回调函数。
*   箭头函数——箭头函数的简洁适合用在回调函数上。
*   闭包——在我们控制生成器的过程中，迭代器在 async 函数内被创建，随之我们在 promise 的回调函数内通过闭包来获取该迭代器。

逻辑代码的书写如下方式：

```
getJSON("data/ninjas.json", (err, ninjas) =>{
  if (err) {
    console.log('Error fetchig ninjas', err);
    return;
  }

  getJSON(ninjas[0].missingsUrl, (err, missions) =>{
    if (err) {
      console.log("Error locating ninja missions", err);
      return;
    }
    console.log(missions);
  })
});
```

不同于把错误处理和流程中控制混合在一起，我们使用类似以下写法结束了代码的混乱：

```
async(function* () {
  try{
    //对每个任务均执行yield
    const ninjas = yield getJSON('data/ninjas.json');
    const missions = yield getJSON(ninjas[0].missionsUrl);
    //Study the mission description
  } catch (e) {
    //依旧可以使用标准的语言结构，诸如try-catch语句或循环语句
    //Oh no,we were not able to get the mission details
  }
});
```

最终结果结合了同步代码和异步代码的优点。有了同步代码，我们能更容易地理解、使用标准控制流以及异常处理机制、try-catch 语句能力。而对于异步代码来说，我们有着天生的阻塞：当等待长时间运行的异步任务时，应用的执行不会被阻塞。

### Set

与数组相似，但是成员唯一，支持… 扩展展开，定义了 iterator 接口支持 for-of 遍历

*   声明的时候可以向里面传输一个可迭代对象，一般我们用数组
*   s.size 可以获取大小
*   s.add(v) 可以添加元素 v
*   s.delete(v) 可以删除元素 v
*   s.has(v) 返回 s 中有没有 v
*   s.clear() 清空 s

```
let s = new Set()
console.log(s,typeof s);            // Set(0) {} object

let s2 = new Set([1,2,3,4,5,3,1])
console.log(s2,typeof s2);          // Set(5) { 1, 2, 3, 4, 5 } object

s2.add(666);
console.log(s2);
s2.delete(3);
console.log(s2);
console.log(s2.has(9))
console.log(s2.has(5))
console.log(s2,s2.size);
s2.clear();
console.log(s2,s2.size);
```

*   数组去重
    
    ```
    let arr = [1,2,3,4,5,6,4,3,2,1];
    console.log([...new Set(arr)])
    ```
    
*   求交
    
    ```
    let arr1 = [1,2,3,4,5,6,4,3,2,1];
    let arr2 = [5,6,7,8,9,8,7,6,5,4];
    let s1 = new Set(arr1);
    let s2 = new Set(arr2);
    let res = [];
    for(d of s1)
      if(s2.has(d))res.push(d);
    console.log(res);
    ```
    
    简化
    
    ```
    let arr1 = [1,2,3,4,5,6,4,3,2,1];
    let arr2 = [5,6,7,8,9,8,7,6,5,4];
    let s2 = new Set(arr2)
    let res = [...new Set(arr1)].filter((d)=>{          // 进行arr1去重
        return s2.has(d)                                // 使用filter判断交集
        // return arr2.indexOf(d)+1                     // 当然可以直接indexOf
    })
    console.log(res)
    ```
    
    语法简化
    
    ```
    let arr1 = [1,2,3,4,5,6,4,3,2,1];
    let arr2 = [5,6,7,8,9,8,7,6,5,4];
    let s2 = new Set(arr2)
    let res = [...new Set(arr1)].filter(d => s2.has(d))
    console.log(res)
    ```
    
*   求并
    
    ```
    let arr1 = [1,2,3,4,5,6,4,3,2,1];
    let arr2 = [5,6,7,8,9,8,7,6,5,4];
    console.log([...new Set([...arr1,...arr2])])
    ```
    
*   求补
    
    ```
    let arr1 = [1, 2, 3, 4, 5, 6, 4, 3, 2, 1];
    let arr2 = [5, 6, 7, 8, 9, 8, 7, 6, 5, 4];
    let s2 = new Set(arr2)
    let res = [...new Set(arr1)].filter(d => !s2.has(d))
    console.log(res)
    ```
    

### Map

与 C++ 的 Map 类似，键支持各种不固定数据类型，支持…, 实现了迭代器支持 for-of

```
let m = new Map();        // 定义一个map
let K3 = {"Name":"Liu"}   // 定义一个key

m.set("Key","value")      // 插入一个映射，两个参数分别是key,value
m.set("Key2",{"A":"B"})   // key/value 可以是基本数据类型，也可以是对象，包括函数
m.set(K3,()=>{console.log("OK")})

console.log(m)
// Map(3) {
//   'Key' => 'value',
//   'Key2' => { A: 'B' },
//   { Name: 'Liu' } => [Function (anonymous)]
// }

console.log(m.size)       // 大小
// 3

m.delete("Key")           // 删除
console.log(m,m.get(K3))  // 获取value
// Map(2) {
//   'Key2' => { A: 'B' },
//   { Name: 'Liu' } => [Function (anonymous)]
// } [Function (anonymous)]


m.get(K3)()               // OK

for(let v of m){          // 遍历
  console.log(v);
}
// [ 'Key2', { A: 'B' } ]
// [ { Name: 'Liu' }, [Function (anonymous)] ]

m.clear();
console.log(m);
// Map(0) {}
```

Map 构造函数可以传入参数`[[key1,val1],[key2,val2],[key3,val3],[key4,val4]]`

### class 类

ES 引入了传统语言中类的写法，实际上 ES6 的 Class 就是一个语法糖，让我们写起来看着像一个传统的 class

**最简单的类定义**

```
class Phone{
  constructor(brand,price){       // 构造函数，名字固定，new的时候执行
    this.brand = brand;
    this.price = price;
  }
  getVal(){                       // 成员方法 不能写function/()=>{}
    return `${this.brand} is ${this.price}`
  }
}

let phone = new Phone("LL",123)
console.log(phone.getVal())
```

**静态成员**

可以和 Java 一样设置类的静态属性

```
class Phone{
  static Name = "手机"            // 使用static
  constructor(brand,price){
    this.brand = brand;
    this.price = price;
  }
  getVal(){                       // 成员方法 不能写function/()=>{}
    return `${this.brand} is ${this.price}`
  }
}

let phone1 = new Phone("LL",123)
let phone2 = new Phone("RR",567)
console.log(phone1.Name)  // undefined
console.log(phone2.Name)  // undefined
console.log(Phone.Name)   // "手机"
```

静态成员属于类而不属于实例

**继承**

在 ES5 中继承的写法是

```
// 父类
function Phone(brand,price){
  this.brand = brand;
  this.price = price;
}

Phone.prototype.getVal=function(){
  return `${this.brand} is ${this.price}`
}

// 子类
function SmtPhone(brand,price,color,size){
  Phone.call(this,brand,price);   // 用this调用Phone的构造
  this.color = color;             // 独有的
  this.size = size;
}

SmtPhone.prototype = new Phone;    // 绑定父级方法
SmtPhone.prototype.constructor = SmtPhone;

SmtPhone.prototype.photo = function(){
  return "a photo";
}

let smtphone = new SmtPhone("A",1,2,3);
console.log(smtphone.getVal())
console.log(smtphone.photo())
```

ES6 类的继承

```
class Phone{
  constructor(brand,price){       // 构造函数，名字固定，new的时候执行
    this.brand = brand;
    this.price = price;
  }
  getVal(){                       // 成员方法 不能写function/()=>{}
    return `${this.brand} is ${this.price}`
  }
}

class SmtPhone extends Phone{
  constructor(brand,price,color,size){
    super(brand,price);       // 与Java一样调用父类
    this.color = color;
    this.size = size;
  }
  photo(){
    return "A Photo";
  }
}

let smtphone = new SmtPhone("Mi",200,1,12)
console.log(smtphone.getVal())
console.log(smtphone.photo())
```

**方法的重写**

在 js 中，我们只能完全重写父类的方法，不能在重写后调用父类的方法

```
class Phone{
  constructor(brand,price){       // 构造函数，名字固定，new的时候执行
    this.brand = brand;
    this.price = price;
  }
  getVal(){                       // 成员方法 不能写function/()=>{}
    return `${this.brand} is ${this.price}`
  }
}

class SmtPhone extends Phone{
  constructor(brand,price,color,size){
    super(brand,price);       // 与Java一样调用父类
    this.color = color;
    this.size = size;
  }
  photo(){
    return "A Photo";
  }
  getVal(){     // 重写
    return `${this.brand} smart phone is ${this.price}`
  }
}

let smtphone = new SmtPhone("Mi",200,1,12)
console.log(smtphone.getVal())
```

**Get 和 Set**

可以对属性进行方法绑定，当要获取属性的时候执行对应 get 方法，当要设置属性值时执行对应的 set 方法, 这些属性不能在构造函数的时候被构造，看起来像一个虚拟变量

```
class GradeList{
  constructor(...grade){
    this.glst = grade;
    // 注意这里不能出现sumn,否则没法读取数据，sumn只能从get sumn获取，不过可以写_sumn方便保存
    this._sumn = null;
  }

  get sumn(){                    // 用于对对象的动态属性进行封装
    let tmp = 0;                 // 注意这里不能用sumn,否则每次for的时候都会跳转到get sumn 直接堆栈溢出
    this.glst.forEach((d,i)=>tmp+=d)
    this._sumn = tmp;            // 顺手保存一手，非必要
    return tmp;                  // 适当时候维护了sumn
  }

  get avg(){
    return this.sumn/this.glst.length
  }

  set sumn(d){                   // 必须有一个参数
    ++d;                         
    this._sumn = d;              // 进行一些处理，非必要，但是没有的话函数也没什么意义了
  }
}

let gst = new GradeList(1,2,3,4,5,6,7,8,9)

gst.sumn = 123;
console.log(gst._sumn)    // 124
console.log(gst.sumn)     // 45
console.log(gst.avg)      // 5
gst.avg = 456;
console.log(gst.avg)      // 5
```

如果设置属性为公有属性, set,get 是无效的

```
class GradeList {
    testVal;                // 尝试注释这行
    constructor(...grade) {
        this.glst = grade;
        this._sumn = null;
    }

    get testVal() {
        console.log("Im ready to get")
        return 1
    }

    set testVal(d) {
        console.log("Im ready to set")
        d+=100;
    }
}

let gst = new GradeList(1,2,3);
gst.testVal=100;
console.log(gst.testVal);
```

结果

注释 testVal 后

```
Im ready to set
Im ready to get
```

### 数值扩展

*   `Number.EPSILON` 表示最小精度，用于浮点数的比较
    
*   `0b/0o/0x`表示二进制八进制十六进制， o/b/x 大小写均可
    
    ```
    console.log(0b1111);//15
    console.log(0o10);//8
    console.log(10);
    console.log(0x10);//16
    ```
    
*   `Number.isFinite()`判断是不是有限
    
    ```
    console.log(Number.isFinite(100)); //true
      console.log(Number.isFinite(100 / 0)); //false
      console.log(Number.isFinite(Infinity));//false
    ```
    
*   `Number.isNaN()`判断是不是 Nan
    
    ```
    console.log(Number.isNaN(NaN)); //true
    console.log(Number.isNaN(123)); //false
    ```
    
*   `Number.parseInt()`字符串转为 Int 与`Number.parseFloat()`字符串转为 Float
    
    ```
    console.log(Number.parseInt('5211314love')); //5211314
    console.log(Number.parseFloat('3.1415926hh')); //3.1415926
    ```
    
*   `Number.isInteger()` 判断一个数是否为整数
    
    ```
    console.log(Number.isInteger(5));   //true
    console.log(Number.isInteger(5.5)); //false
    ```
    
*   `Math.trunc()`抹掉数字的小数部分
    
    ```
    console.log(Math.trunc(3.555));  //3
    console.log(Math.trunc(0.555));  //0
    ```
    
*   Math.sign 判断一个数是正数还是负数还是 0, 有三个值 +:1， 0:0， -:-1
    
    ```
    console.log(Math.sign(100));  //1
    console.log(Math.sign(0));     // 0
    console.log(Math.sign(-100)); //-1
    ```
    

### 对象方法的扩展

*   `Object.is()`判断两个值是否相等, 作用与 === 相似，区别是`is(NaN,NaN)`有区别
    
    ```
    console.log(Object.is(1,1))               // True
    console.log(Object.is(1,2))               // False
    console.log(Object.is([1],[1]))           // False
    console.log(Object.is({A:"1"},{A:"1"}))   // False
    console.log(Object.is({A:"1"},{A:1}))     // False
    // 关于NaN
    console.log(Object.is(NaN,NaN))           // True
    console.log(NaN === NaN)                  // False
    console.log(Number("Hi"));                // NaN
    console.log(Number("Hi")===NaN)           // False
    console.log(Object.is(Number("Hi"),NaN))  // True
    ```
    
*   `Object.assign()`对象合并, 可以合并对象, 例如 Axios 的时候三个配置文件合并可以写成
    
    ```
    let defaultConfig = {
      "url": "127.0.0.1",
      "port": 9000,
      method: "GET"
    }
    let config = {
      "url": "127.9.9.9",
    }
    config = Object.assign(defaultConfig,config,{"A":1})
    console.log(config)
    ```
    
    后者会覆盖前者
*   `Object.setPrototypeOf()`/`Object.setPrototypeOf()` 可以为对象设置原型
    
    ```
    let chd = {
      pos: "child",
      value: 1
    }
    let prt = {
      pos: "parent",
      value: 2
    }
    // 设置chd的原型是prt
    Object.setPrototypeOf(chd,prt);
    console.log(chd.__proto__)                // prt
    console.log(Object.getPrototypeOf(chd))   // prt
    ```
    

### 模块化

模块化可以防止命名冲突，直线代码复用，提高维护性

在 ES6 之前，JS 本身没有模块化规范，社区推出的规范有

*   CommonJS 规范: 这种规范的代表有 NodeJS, Browserify
*   AMD 规范: 这种规范的代表有 requireJS
*   CMD 规范: 这种规范的代表有 SeaJS

**ES6 模块化**

由两个命令构成

*   `export` 规定导出接口，与 Node 不太一样，只是前面加一个标识就可以了
*   `import` 导入其他模块

mod.js 文件

```
export let name = "Hi"
export let nowis=()=> Date.now()
```

index.html

```
<script type="module">              // 要写type
  import * as m1 from "../mod.js"   // 导入为m1
  console.log(m1.nowis());          // 调用方法
</script>
```

**暴露数据的方法**

*   分别暴露

```
export let name = "Hi"
export let nowis=()=> Date.now()
```

*   统一暴露

```
let name = "Hi"
let nowis=()=> Date.now()
export {name,nowis}
```

*   默认暴露

```
export default{
  name : "Hi",
  nowis: function(){return Date.now()}
}
```

默认暴露需要修改 html

```
<script type="module">
  import * as m1 from "../mod.js"
  console.log(m1.default.nowis())    // 多个default
</script>
```

**浏览器引用模块的方法**

*   通用引用方法

```
<script type="module">
  import * as m1 from "../mod.js"
</script>
```

*   解构的方式引用

```
<script type="module">
  import {name,nowis} from "../mod.js"
</script>
```

如果两个模块有同名函数，解构后会出现变量名重复的问题，可以使用 as 进行变量名的替换，不影响解构

```
<script type="module">
  import {name,nowis} from "../mod1.js" // 有name nowis
  import {name as name2,lstis} from "../mod2.js" // 有name lstis
</script>
```

*   针对默认暴露的简便模式

```
<script type="module">
  import m1 from "../mod1.js" // 因为默认暴露只有一个参数，可以这么做
</script>
```

**文件统一引用**

可以把所有模块引用都放在一起，然后直接引用这个文件

app.js

```
import * as m1 from "../mod1.js"
import * as m2 from "../mod2.js"
import * as m3 from "../mod3.js"
```

index.html

```
<script type="module" src="./app.js">
```

**将 ES6 代码转化为 ES5 代码**

在项目中考虑到项目兼容性，需要将项目的 JS 进行转化，需要的工具有

*   Babel: 将 ES6 代码转化为 ES5 代码，但是是 CommonJS 规范
*   browserify: 打包工具，把 CommonJS 规范的 JS 转化为浏览器可读的，这里是简易打包，项目可能需要 webpack

```
npm install babel-cli babel-preset-env browserify -D  // 软件分别是 命令行 工具 打包工具 -D是开发依赖
npx babel ./src -d ./dist/js --preset=babel-preset-env  // -d前是原js目录 -d后是输出目录 最后是使用预设
npx browserify dist/js/mod.js -o ./bundle.js          // 打包
```

浏览器最后引用`./bundle.js`

**将 npm 包引入浏览器, jQuery 为例**

bash

```
npm install jquery
```

./src/js/app.js

```
import $ from "jquery";
$("body").css("background","pink");
```

bash

```
npx babel ./src/js -d ./dist/js --preset=babel-preset-env
npx browserify ./dist/js/app.js -o ./dist/bundle.js
```

ES7 新特性
-------

### Array 的 includes

用来判断元素在不在数组

```
const s = ["AA","BB","CC","DD"]
console.log(s.includes("BB"))   // true
console.log(s.includes("EE"))   // false
```

### ** 运算符

与 python 的 ** 一样，用来算指数，Math.pow() 功能一样

```
console.log(Math.pow(5,3))    // 125
console.log(5**3)             // 125
```

ES8 新特性
-------

### async & await

async/await 是一种新的异步函数同步解决方案

**async**

*   async 可以放在函数前，定义 async 函数，这种函数的返回值是会被转化为 Promise
*   async 函数的返回值如果是是非 Promise 对象，那么会将`return val`的结果转化为`Promise.resolve(val)`, 即使 val 是 undefined
*   async 函数中如果抛出异常，那么会返回 Promise.reject
*   async 函数如果返回 Promise 对象，那么会直接返回
*   不能在全局直接声明 async 函数，实在不行可以写成
    
    ```
    (async()=>{})()
    ```
    
    的立即执行函数

**await**

*   await 必须写在 async 函数中
*   await 右侧的表达式一般是 Promise 对象，也可以是正常值
*   await 的结果是 Promise 成功的**值**，如果 Promise 的结果是 reject, 那么会抛出异常

详见 Promise 内容

### 对象方法的扩展

*   `Object.keys()`获取对象所有的**键名**，返回值是数组
    
    ```
    let lower = {
      "A":"a",
      "B":"b",
      "C":"c",
      "D":"d",
    }
    
    Object.keys(lower).forEach(d=>console.log(d))  // A B C D
    ```
    
*   `Object.values()`获取对象所有的**值**，返回值是数组
    
    ```
    let lower = {
      "A":"a",
      "B":"b",
      "C":"c",
      "D":"d",
    }
    
    console.log(Object.values(lower))
    // [ 'a', 'b', 'c', 'd' ]
    ```
    
*   `Object.entries()`获取对象所有的**键值对**，返回值是数组，元素是一个数组，包含键和值, 可以用来构造 Map
    
    ```
    let lower = {
      "A":"a",
      "B":"b",
      "C":"c",
      "D":"d",
    }
    console.log(Object.entries(lower))
    // [ [ 'A', 'a' ], [ 'B', 'b' ], [ 'C', 'c' ], [ 'D', 'd' ] ]
    let m = new Map(Object.entries(lower))
    console.log(m)
    // Map(4) { 'A' => 'a', 'B' => 'b', 'C' => 'c', 'D' => 'd' }
    ```
    
*   `Object.getOwnPropertyDescriptors()`获取对象属性的描述对象，这个对象的每一个属性都对应描述中的一个对象，包括值，可写，可删除，可枚举，方便我们进行深层次的对象克隆
    
    ```
    let lower = {
        "name": "a",
        "age": 12,
        "sex": "F",
        "note": "good",
    }
    
    console.log(Object.getOwnPropertyDescriptors(lower))
    /**
    {
        name: { value: 'a', writable: true, enumerable: true, configurable: true },
        age: { value: 12, writable: true, enumerable: true, configurable: true },
        sex: { value: 'F', writable: true, enumerable: true, configurable: true },
        note: {
            value: 'good',
            writable: true,
            enumerable: true,
            configurable: true
        }
    }
    */
    ```
    

ES9 新特性
-------

### REST 参数与 Spread 扩展

在 ES6 中只有对数组的 REST/Spread, 在 ES9 中支持对对象进行 REST/Spread

**REST**

```
function cnnt({host,port,...args}){
    console.log(host);
    console.log(port);
    console.log(args);          // 对象的rest就是一个对象
}

cnnt({
    host: "127.0.0.1",
    port: 80,
    pwd: 123,
    type: "A"
})
// 127.0.0.1
// 80
// { pwd: 123, type: 'A' }
```

**Spread**

```
let Obj1={
    "name":"Liu"
}

let Obj2={
    "Sex":"M"
}

let Obj3={
    "Age":20
}

let res = {...Obj1,...Obj2,...Obj3}
console.log(res)
// { name: 'Liu', Sex: 'M', Age: 20 }
```

### 正则扩展

**命名捕获分组**

我们可以对政策匹配到的分组`$1,$2...`赋名，方面我们的使用

在之前

```
let str = '<iframe class="notranslate">Inner</iframe>';
// 想要获取class和标签内容要写两个()用来分组
let reg = /class="(.*)\".*>(.*)<\/iframe/;
let res = reg.exec(str);
console.log(res);
```

结果是

```
[
  'class="notranslate">Inner</iframe',
  'notranslate',
  'Inner',
  index: 8,
  input: '<iframe class="notranslate">Inner</iframe>',
  groups: undefined       // 这里是undefined
]
```

也就是 res[0] 是匹配结构, res[1] 是第一个分组, res[2] 是第二个分组

将需要赋值的分组括号由`(条件)`改为`(?<变量名>条件)`, 使用捕获分组会存储着 groups 中

```
let str = '<iframe class="notranslate">Inner</iframe>';
// 想要获取class和标签内容要写两个()用来分组
let reg = /class="(?<cls>.*)\".*>(?<Inn>.*)<\/iframe/;
let res = reg.exec(str);
console.log(res);
console.log(res.groups.cls);
console.log(res.groups.Inn);
```

结果是

```
[
  'class="notranslate">Inner</iframe',      // [0-2]都没有变
  'notranslate',
  'Inner',
  index: 8,
  input: '<iframe class="notranslate">Inner</iframe>',
  groups: [Object: null prototype] { cls: 'notranslate', Inn: 'Inner' }
  // groups变了
]
notranslate       // 可以直接输出了
Inner
```

就可以直接使用对应变量了, 在修改正则的时候也不用修改下标了

**反向断言**

正向断言是匹配某个串要求不仅要满足串的条件, 原串后面的内容也要满足指定条件, 例如: 对于子复查 u 年’aaa111bbb222’我想要最后一个连续的字母, 那么应该匹配的是`[a-zA-Z]+`并且后面是`2`实现方法是**在正则条件后加上 (?= 后面的内容)**, 这里要匹配的内容不用分组, 因为我们这个方法就是要一次性匹配到结果

```
let str = 'aaa111bbb222';
let reg = /[a-zA-Z]+(?=2)/
let res = reg.exec(str);
console.log(res)
// [ 'bbb', index: 6, input: 'aaa111bbb222', groups: undefined ]
```

反向断言是要匹配一个串, 满足串前面的内容是指定条件. 实现方法是 **(?<= 前面的内容) 条件 **, 例如我想匹配第一个出现的数字串

```
let str = 'aaa111bbb222';
let reg = /(?<=a)[0-9]+/
let res = reg.exec(str);
console.log(res)
// [ '111', index: 3, input: 'aaa111bbb222', groups: undefined ]
```

**dotAll 模式**

在正则中`.`代表任意除`\n`外的任意内容, 在提取有`\n`的内容的时候就显得不方便, 只需要设置`/条件/s`即可, 就是在最后加入 s 属性

`.*`用来匹配任意字符串的时候经常出现贪婪匹配, 可以设置`.*?`禁止贪婪

ES10 新特性
--------

### Object.fromEntries 方法

*   `Object.entries()`可以获取对象所有的**键值对**，返回值是数组，元素是一个数组，包含键和值, 可以用来构造 Map
*   `Object.fromEntries()`可以将一个 Map / 二维数组转化为对象的形式

```
let ary = [
    ['A','a'],
    ['B','b'],
    ['C','c'],
    ['D','d'],
];

let res = Object.fromEntries(ary);
console.log(res)
// { A: 'a', B: 'b', C: 'c', D: 'd' }
```

### trimStart/trimEnd 方法

在 ES5 中字符串有 trim 方法用来清除字符串两边的空白, 现在有 start/end 指定清除哪一边了空白

```
let s = '   abc     ';
console.log(s.trim(),s.trim().length)   //abc 3
console.log(s.trimStart(),s.trimStart().length)   //abc      8
console.log(s.trimEnd(),s.trimEnd().length)   //   abc 6
```

### Array.flat/flatMap 方法

flat 译为平面, 也就是可以将数组内部数组的元素维度降低, 例如

```
let arr1 = [1,2,[3,4]];
let arr2 = [1,2,[3,4,[5,6]]];

console.log(arr1.flat());         // [ 1, 2, 3, 4 ]
console.log(arr2.flat());         // [ 1, 2, 3, 4, [ 5, 6 ] ]
console.log(arr2.flat().flat());  // [ 1, 2, 3, 4, 5, 6 ]
console.log(arr2.flat(2));        // [ 1, 2, 3, 4, 5, 6 ] 可以在括号中指定深度,默认1
```

flatMap 可以将 map 的结果进行降维, 这里的 map 和 Map 不同, 类似于 python 的 map 做批量操作

```
let arr = [1,2,3,4];

let res1 = arr.map(item => item*10)
console.log(res1)
// [ 10, 20, 30, 40 ]
let res2 = arr.map(item => [item*10,item*10+1])
console.log(res2)
// [ [ 10, 11 ], [ 20, 21 ], [ 30, 31 ], [ 40, 41 ] ]
let res3 = arr.flatMap(item => [item*10,item*10+1])
console.log(res3)
// [ 10, 11, 20, 21, 30, 31, 40, 41 ]
```

### Symbol.description 方法

可以用`Symbol.description`方法获取 Symbol 的注释

```
let s = Symbol("我是一个注释")
console.log(s.description)  // 我是一个注释
```

ES11 新特性
--------

### 私有属性

在传统 OOP 语言中的对象可以是私有的, ES11 引入了这个特性, 定义私有属性只要在前面加入`#`就可以了

```
class Psn{
    name;       // 公有的
    #age;       // 私有的
    constructor(name,age){
        this.name = name;
        this.#age = age;
    }
    getIt(){
        return {"N":this.name,"A":this.#age};
    }
}

let psn = new Psn("Liu",12);
console.log(psn.getIt());  // { N: 'Liu', A: 12 }
console.log(psn.name)      // Liu
console.log(psn.#age)      // Error
```

### Promise.allSettled 方法

可以指定一个变量为`Promise.allSettled()`, 他会运行一系列 Promise, 当全部运行结束后, 不论他包含的 Promise 的结果是什么, 状态都变为 resolved, 并保存每个 Promise 的结果

```
let p1 = new Promise((res,rej)=>{
    setTimeout(()=>{
        console.log("OK");
        res("Im P1");
    },1000);
})

let p2 = new Promise((res,rej)=>{
    setTimeout(()=>{
        console.log("NK");
        rej("Im P2");
    },1000);
})

let p3 = new Promise((res,rej)=>{
    setTimeout(()=>{
        console.log("OK");
        res("Im P3");
    },1000);
})

let result = Promise.allSettled([p1,p2,p3]);
console.log(result)
setTimeout(()=>console.log(result),5000)            // 延时显示等待Promise结束
```

结果是

```
Promise { <pending> }
OK
NK
OK
Promise {
  [
    { status: 'fulfilled', value: 'Im P1' },
    { status: 'rejected', reason: 'Im P2' },
    { status: 'fulfilled', value: 'Im P3' }
  ]
}
```

与他很像的是`Promise.all()`方法, 他的结果是所有结果取`AND`, 他们都用来做批量异步任务, all 一般是用来做前一个成功后一个运行, allSettled 一般是要全部运行, 之间没有关联, 要求保存结果

### String.matchAll 方法

如果正则表达式有 / g 标志，那么多次调用. exec() 就会得到所有匹配的结果。如果没有匹配的结果，.exec() 就会返回 null。在这之前会返回每个匹配的匹配对象。这个对象包含捕获的子字符串和更多信息. 如果正则表达式没有 / g 标志，.exec() 总是返回第一次匹配的结果。

```
const matchIterator = str.matchAll(regExp);
```

给定一个字符串和一个正则表达式，.matchAll（）为所有匹配的匹配对象返回一个迭代器。也可以使用一个扩展运算符… 把迭代器转换为数组。

```
[...'-a-a-a'.matchAll(/-(a)/ug)]
//[ [ '-a', 'a' ], [ '-a', 'a' ], [ '-a', 'a' ] ]
```

现在是否设置 / g，都不会有问题了。

```
[...'-a-a-a'.matchAll(/-(a)/u)]
// [ [ '-a', 'a' ], [ '-a', 'a' ], [ '-a', 'a' ] ]
```

### 可选链操作符号

在以前我们想访问一个对象很深的属性要进行多次尝试防止出现访问`undefined.XXX`, 例如

```
let d = {
  name:{
    fname:{
      pub: true,
      value: "Liu"
    },
    lname:{
      pub : false,
    }
  }
}

let fnm = d.name&&d.name.fname&&d.name.fname.value    // 要一直尝试
let lnm = d.name&&d.name.lname&&d.name.lname.value    // 要一直尝试
console.log(fnm,lnm)    // Liu undefined
```

可选链的操作符是`?.`, 例如`A?.B`就是 A 存在才去读取 B, 例如

```
let d = {
  name:{
    fname:{
      pub: true,
      value: "Liu"
    },
    lname:{
      pub : false,
    }
  }
}

let fnm = d?.name?.fname?.value
let lnm = d?.name?.lname?.value
console.log(fnm,lnm)    // Liu undefined
```

### 动态 Import

动态导入支持按需加载模块 / 懒加载, 而不是一股脑的在开头加载, 语法是`import("path")`, 返回的是一个 Promise 对象, 当正确加载就 resolve, resolve 的值是模块暴露的对象

*   静态导入
    
    ```
    // 文件头
    import * as md1 from "./demo.js"
    ```
    
*   动态导入
    
    ```
    if(something){
      import("./demo.js").then((d)=>{
        d.xx();     // d就是暴露的对象
      })
    }
    ```
    

### BigInt 类型

比 int 类范围大, 用于大数运算

*   字面值写法: `123n`
*   Int 转 BigInt:`BigInt(123)`
*   BigInt 不能和 int 进行运算, 必须把 int 转为 BigInt, 例如
    
    ```
    let i = 123n
    console.log(i)              // 123n
    console.log(i+10)           // Error
    console.log(i+BigInt(10))   // 133n
    ```
    

### 绝对全局对象

浏览器的全局对象是 window, 但是 NodeJS 等没有 window, 在新的 NodeJS / 浏览器中都可以使用`golbalThis`指向全局对象, 使得在浏览器 / NodeJS 中编程得到了一个统一

```
// @Node
console.log(globalThis)
// <ref *1> Object [global] {
//   global: [Circular *1],
//   clearInterval: [Function: clearInterval],
//   clearTimeout: [Function: clearTimeout],
//   setInterval: [Function: setInterval],
//   setTimeout: [Function: setTimeout] {
//     [Symbol(nodejs.util.promisify.custom)]: [Getter]
//   },
//   queueMicrotask: [Function: queueMicrotask],
//   performance: [Getter/Setter],
//   clearImmediate: [Function: clearImmediate],
//   setImmediate: [Function: setImmediate] {
//     [Symbol(nodejs.util.promisify.custom)]: [Getter]
//   }
// }

// @Chrome
console.log(globalThis)
// Window {0: Window, 1: Window, window: Window, self: Window, document: document, name: "", location: Location, …}
```

ES12 新特性
--------

转载自: [前端虾米公社](https://blog.csdn.net/qq_37393635/article/details/109461000)

### replaceAll

看到 replaceAll 这个词，相比很容易联想到 replace。在 JavaScript 中，replace 方法只能是替换字符串中匹配到的第一个实例字符，而不能进行全局多项匹配替换，唯一的办法是通过正则表达式进行相关规则匹配替换

而 replaceAll 则是返回一个全新的字符串，所有符合匹配规则的字符都将被替换掉，替换规则可以是字符串或者正则表达式。

```
let string = 'I like 前端,I like 前端公虾米'
//使用replace
let replaceStr = string.replace('like','love')
console.log(replaceStr)  // 'I love 前端,I like前端公虾米'
//replace使用正则匹配所有
console.log(string.replace(/like/g,'love')) // 'I love 前端,I love 前端公虾米'
//使用replaceAll
let replaceAllStr = string.replaceAll('like','love')
console.log(replaceAllStr) // 'I love 前端,I love 前端公虾米'
```

需要注意的是，replaceAll 在使用正则表达式的时候，如果非全局匹配（/g），则 replaceAll() 会抛出一个异常

```
let string = 'I like 前端,I like 前端公虾米'
console.log(string.replaceAll(/like/,'love')) //TypeError
```

### Promise.any

当 Promise 列表中的任意一个 promise 成功 resolve 则返回第一个 resolve 的结果状态

如果所有的 promise 均 reject，则抛出异常表示所有请求失败

```
Promise.any([
  new Promise((resolve, reject) => setTimeout(reject, 500, '哎呀，我被拒绝了')),
  new Promise((resolve, reject) => setTimeout(resolve, 1000, '哎呀，她接受我了')),
  new Promise((resolve, reject) => setTimeout(resolve, 2000, '哎呀，她也接受我了')),
])
.then(value => console.log(`输出结果: ${value}`))
.catch (err => console.log(err))

//输出
//输出结果:哎呀，她接受我了
```

再来看下另一种情况

```
Promise.any([
  Promise.reject('Error 1'),
  Promise.reject('Error 2'),
  Promise.reject('Error 3')
])
.then(value => console.log(`请求结果: ${value}`))
.catch (err => console.log(err))

//输出
AggregateError: All promises were rejected
```

Promise.any 与 Promise.race 十分容易混淆，务必注意区分，Promise.race 一旦某个 promise 触发了 resolve 或者 reject，就直接返回了该状态结果，并不在乎其成功或者失败

### WeakRefs

使用 WeakRefs 的 Class 类创建对对象的弱引用 (对对象的弱引用是指当该对象应该被 GC 回收时不会阻止 GC 的回收行为)

当我们通过（const、let、var）创建一个变量时，垃圾收集器 GC 将永远不会从内存中删除该变量，只要它的引用仍然存在可访问。WeakRef 对象包含对对象的弱引用。对对象的弱引用是不会阻止垃圾收集器 GC 恢复该对象的引用，则 GC 可以在任何时候删除它。

WeakRefs 在很多情况下都很有用，比如使用 Map 对象来实现具有很多需要大量内存的键值缓存，在这种情况下最方便的就是尽快释放键值对占用的内存。

目前，可以通过 WeakMap() 或者 WeakSet() 来使用 WeakRefs

举个栗子

我想要跟踪特定的对象调用某一特定方法的次数，超过 1000 条则做对应提示

```
let map = new Map()
function doSomething(obj){
	...
}
function useObject(obj){
	doSomething(obj)
  
  let called = map.get(obj) || 0
  called ++ 
  
  if(called>1000){
     console.log('当前调用次数已经超过1000次了，over')
  }
  
  map.set(obj, called)
}
```

如上虽然可以实现我们的功能，但是会发生内存溢出, 因为传递给 doSomething 函数的每个对象都永久保存在 map 中，并且不会被 GC 回收，因此我们可以使用 WeakMap

```
let wmap = new WeakMap()
function doSomething(obj){
	...
}
function useObject(obj){
	doSomething(obj)
  
  let called = wmap.get(obj) || 0
  
  called ++
  
  if(called>1000){
     console.log('当前调用次数已经超过1000次了，over')
  }
  
  wmap.set(obj, called)
}
```

因为是弱引用，所以 WeakMap、WeakSet 的键值对是不可枚举的

WeakSet 和 WeakMap 相似，但是每个对象在 WeakSet 中的每个对象只可能出现一次，WeakSet 中所有对象都是唯一的

```
let ws = new WeakSet()
let foo = {}
let bar = {}

ws.add(foo)
ws.add(bar)

ws.has(foo) //true
ws.has(bar) //true

ws.delete(foo) //删除foo对象
ws.has(foo) //false 已删除
ws.has(bar) //仍存在
```

WeakSet 与 Set 相比有以下两个区别

WeakSet 只能是对象集合，而不能是任何类型的任意值  
WeakSet 弱引用，集合中对象引用为弱引用，如果没有其他对 WeakSet 对象的引用，则会被 GC 回收  
最后，WeakRef 实例有一个方法 deref，返回引用的原始对象，如果原始对象被回收，则返回 undefined

```
const cache = new Map();

const setValue =  (key, obj) => {
  cache.set(key, new WeakRef(obj));
};

const getValue = (key) => {
  const ref = cache.get(key);
  if (ref) {
    return ref.deref();
  }
};

const fibonacciCached = (number) => {
  const cached = getValue(number);
  if (cached) return cached;
  const sum = calculateFibonacci(number);
  setValue(number, sum);
  return sum;
};
```

对于缓存远程数据来说，这可能不是一个好主意，因为远程数据可能会不可预测地从内存中删除。在这种情况下，最好使用 LRU 之类的缓存。

### 逻辑运算符和赋值表达式

逻辑运算符和赋值表达式，新特性结合了逻辑运算符（&&，||，??）和赋值表达式而 JavaScript 已存在的  
复合赋值运算符有：

操作运算符：+= -= *= /= %= **=  
位操作运算符：&= ^= |=  
按位运算符：<<=>>= >>>=  
现有的的运算符，其工作方式都可以如此来理解

表达式：`a op= b` 等同于：`a = a op b`

逻辑运算符和其他的复合赋值运算符工作方式不同

表达式：`a op= b` 等同于：`a = a op (a = b)`

*   `a ||= b` 等价于 `a = a || (a = b)`
*   `a &&= b` 等价于 `a = a && (a = b)`
*   `a ??= b` 等价于 `a = a ?? (a = b)`

为什么不再是跟以前的运算公式`a = a op b`一样呢，而是采用`a = a op (a = b)`。因为后者当且仅当 a 的值为 false 的时候才计算赋值，只有在必要的时候才执行分配，而前者的表达式总是执行赋值操作

*   `??=`可用来补充 / 初始化缺失的属性

```
const pages = [
  {
  	title:'主会场',
    path:'/'
  },
  {
    path:'/other'
  },
  ...
]
  
for (const page of pages){
	page.title ??= '默认标题'
}
console.table(pages)
//(index)  title       		path
//0        "主会场"   	  "/"
//1        "默认标题"  	 "/other"
```

小结：

*   `&&=`: 当 LHS 值存在时，将 RHS 变量赋值给 LHS
*   `||=`: 当 LHS 值不存在时，将 RHS 变量赋值给 LHS
*   `??=`: 当 LHS 值为 null 或者 undefined 时，将 RHS 变量赋值给 LHS

### 数字分隔符

数字分隔符，可以在数字之间创建可视化分隔符，通过_下划线来分割数字，使数字更具可读性

```
const money = 1_000_000_000
//等价于
const money = 1000000000

const totalFee = 1000.12_34
//等价于
const totalFee = 1000.1234
```

该新特性同样支持在八进制数中使用

```
const number = 0o123_456
//等价于
const number = 0o123456
```