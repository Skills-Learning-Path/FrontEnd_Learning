> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [blog.csdn.net](https://blog.csdn.net/earthOLtainanwan/article/details/97945066?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163473836216780264059859%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=163473836216780264059859&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-97945066.first_rank_v2_pc_rank_v29&utm_term=%E5%B0%9A%E7%A1%85%E8%B0%B7js%E9%AB%98%E7%BA%A7&spm=1018.2226.3001.4187)

 **JS 高级**



▲基础总结深入
=======

数据类型
----

![](https://img-blog.csdnimg.cn/20190731194114872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190731194125810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190731194138507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

数据、变量、内存
--------

![](https://img-blog.csdnimg.cn/20190731194213110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190731194226167.png)  
![](https://img-blog.csdnimg.cn/20190731194235442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190731194321103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190731194305937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

对象
--

![](https://img-blog.csdnimg.cn/20190731194354145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190731194406961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

函数
--

![](https://img-blog.csdnimg.cn/20190731194421801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

回调函数
----

![](https://img-blog.csdnimg.cn/20190731194437372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

IIFE
----

![](https://img-blog.csdnimg.cn/2019073119445224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

this
----

![](https://img-blog.csdnimg.cn/20190731194506343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

基础总结
----

**数据类型的分类和判断：**

*   基本 (值) 类型
    *   Number ----- 任意数值 -------- typeof
    *   String ----- 任意字符串 ------ typeof
    *   Boolean ---- true / false ----- typeof
    *   undefined — undefined ----- typeof / ===
    *   null -------- null ---------- ===
*   对象 (引用) 类型
    *   Object ----- typeof / instanceof
    *   Array ------ instanceof
    *   Function ---- typeof

**数据, 变量, 内存的理解：**

*   什么是数据?
    *   在内存中可读的, 可传递的保存了特定信息的’东东’
    *   一切皆数据, 函数也是数据
    *   在内存中的所有操作的目标: 数据
*   什么是变量?
    *   在程序运行过程中它的值是允许改变的量
    *   一个变量对应一块小内存, 它的值保存在此内存中
*   什么是内存?
    *   内存条通电后产生的存储空间 (临时的)
    *   一块内存包含 2 个方面的数据：
        *   内部存储的数据
        *   地址值数据
    *   内存空间的分类：
        *   栈空间: 全局变量和局部变量
        *   堆空间: 对象
*   内存, 数据, 变量三者之间的关系：
    *   内存是容器, 用来存储不同数据
    *   变量是内存的标识, 通过变量我们可以操作 (读 / 写) 内存中的数据

**对象的理解和使用：**

*   什么是对象?
    *   多个数据 (属性) 的集合
    *   用来保存多个数据 (属性) 的容器
*   属性组成:
    *   属性名 : 字符串 (标识)
    *   属性值 : 任意类型
*   属性的分类:
    *   一般 : 属性值不是 function 描述对象的状态
    *   方法 : 属性值为 function 的属性 描述对象的行为
*   特别的对象
    *   数组: 属性名是 0,1,2,3 之类的索引
    *   函数: 可以执行的
*   如何操作内部属性 (方法)
    *   . 属性名
    *   [‘属性名’]: 属性名有特殊字符 / 属性名是一个变量

**函数的理解和使用：**

*   什么是函数?
    *   用来实现特定功能的, n 条语句的封装体
    *   只有函数类型的数据是可以执行的, 其它的都不可以
*   为什么要用函数?
    *   提高复用性
    *   便于阅读交流
*   函数也是对象
    *   instanceof Object === true
    *   函数有属性: prototype
    *   函数有方法: call() / apply()
    *   可以添加新的属性或方法
*   函数的 3 种不同角色
    *   一般函数 : 直接调用
    *   构造函数 : 通过 new 调用
    *   对象 : 通过. 调用内部的属性 / 方法
*   函数中的 this
    *   显式指定谁: [obj.xxx](http://obj.xxx)()
    *   通过 call/apply 指定谁调用: xxx.call(obj)
    *   不指定谁调用: xxx() : window
    *   回调函数: 看背后是通过谁来调用的: window / 其它
*   匿名函数自调用:
    
    ```
    (function(w, obj){
      //实现代码
    })(window, obj)
    ```
    
    *   专业术语为: IIFE (Immediately Invoked Function Expression) 立即调用函数表达式
*   回调函数的理解
    *   什么函数才是回调函数?
        *   你定义的
        *   你没有调用
        *   但它最终执行了 (在一定条件下或某个时刻)
    *   常用的回调函数
        *   dom 事件回调函数
        *   定时器回调函数
        *   ajax 请求回调函数 (后面讲解)
        *   生命周期回调函数 (后面讲解)

关于分号的问题
-------

![](https://img-blog.csdnimg.cn/20190731194647126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190731194657833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
图中所示链接：

1.  Hacking Semicolons by Evan You：  
    [http://slides.com/evanyou/semicolons#/](http://slides.com/evanyou/semicolons#/)
2.  yyx990803/vue·GitHub:  
    [https://github.com/yyx990803/vue](https://github.com/yyx990803/vue)
3.  yyx990803/semi·GitHub:  
    [https://github.com/yyx990803/semi](https://github.com/yyx990803/semi)

▲函数高级
=====

原型与原型链
------

### 函数的 prototype 属性

![](https://img-blog.csdnimg.cn/20190731194814993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

### 显示原型与隐式原型

![](https://img-blog.csdnimg.cn/20190731194833366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190731194842780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

### 原型链

![](https://img-blog.csdnimg.cn/20190731194857608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190731194906412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190731194915219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190731194926825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

### 原型链的属性问题

![](https://img-blog.csdnimg.cn/20190731194951712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

### instanceof

![](https://img-blog.csdnimg.cn/20190731195010656.png)  
![](https://img-blog.csdnimg.cn/2019073119501920.png)  
![](https://img-blog.csdnimg.cn/20190731195027631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190731195037471.png)  
![](https://img-blog.csdnimg.cn/20190731195046234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

### 原型测试题

**测试题 1：**  
![](https://img-blog.csdnimg.cn/20190731195117202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190731195142575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
**测试题 2：**  
![](https://img-blog.csdnimg.cn/20190731195158458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

执行上下文与执行上下文栈
------------

### 变量提升与函数提升

![](https://img-blog.csdnimg.cn/20190731195232758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

### 执行上下文

![](https://img-blog.csdnimg.cn/20190731195249298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190731195303574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

### 执行上下文栈

![](https://img-blog.csdnimg.cn/20190731195415865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190731195426160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190731195437279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190731195445801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

### 执行上下文测试题

**测试题 1：**  
![](https://img-blog.csdnimg.cn/20190731195510912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
**测试题 2：**  
![](https://img-blog.csdnimg.cn/20190731195528675.png)  
**测试题 3：**  
![](https://img-blog.csdnimg.cn/20190731195542444.png)  
**测试题 4：**  
![](https://img-blog.csdnimg.cn/20190731195557256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

作用域与作用域链
--------

### 作用域

![](https://img-blog.csdnimg.cn/20190731195845762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190731195856533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

### 作用域与执行上下文

![](https://img-blog.csdnimg.cn/20190731195915984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190731195924233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

### 作用域链

![](https://img-blog.csdnimg.cn/20190731195941578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190731195950728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

### 作用域测试题

**测试题 1：**  
![](https://img-blog.csdnimg.cn/20190731200052820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
**测试题 2：**  
![](https://img-blog.csdnimg.cn/20190731200108331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

[闭包](https://so.csdn.net/so/search?q=%E9%97%AD%E5%8C%85&spm=1001.2101.3001.7020)
--------------------------------------------------------------------------------

### 引入

![](https://img-blog.csdnimg.cn/20190731200130417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

### 闭包的概念

![](https://img-blog.csdnimg.cn/20190731200147971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190731200157116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

### 闭包的作用

![](https://img-blog.csdnimg.cn/20190731200211843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

### 闭包的生命周期

![](https://img-blog.csdnimg.cn/2019073120022621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

### 闭包的应用

![](https://img-blog.csdnimg.cn/20190731200630540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190731200640832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190731200659693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190731200709342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

### 闭包的缺点

![](https://img-blog.csdnimg.cn/20190731200724446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

### 内存溢出与内存泄露

![](https://img-blog.csdnimg.cn/20190731200741594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

### 闭包测试题

**测试题 1：**  
![](https://img-blog.csdnimg.cn/20190731200805640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
**测试题 2：**  
![](https://img-blog.csdnimg.cn/2019073120082294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

函数高级总结
------

**原型与原型链：**

*   所有函数都有一个特别的属性:
    *   `prototype` : 显式原型属性
*   所有实例对象都有一个特别的属性:
    *   `__proto__` : 隐式原型属性
*   显式原型与隐式原型的关系
    *   函数的`prototype`: 定义函数时被自动赋值, 值默认为 {}, 即用为原型对象
    *   实例对象的`__proto__`: 在创建实例对象时被自动添加, 并赋值为构造函数的 prototype 值
    *   原型对象即为当前实例对象的父对象
*   原型链
    *   所有的实例对象都有`__proto__`属性, 它指向的就是原型对象
    *   这样通过`__proto__`属性就形成了一个链的结构 ----> 原型链
    *   当查找对象内部的属性 / 方法时, js 引擎自动沿着这个原型链查找
    *   当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作

**执行上下文与执行上下文栈：**

*   变量提升与函数提升
    *   变量提升: 在变量定义语句之前, 就可以访问到这个变量 (undefined)
    *   函数提升: 在函数定义语句之前, 就执行该函数
    *   先有变量提升, 再有函数提升
*   理解
    *   执行上下文: 由 js 引擎自动创建的对象, 包含对应作用域中的所有变量属性
    *   执行上下文栈: 用来管理产生的多个执行上下文
*   分类:
    *   全局: window
    *   函数: 对程序员来说是透明的
*   生命周期
    *   全局 : 准备执行全局代码前产生, 当页面刷新 / 关闭页面时死亡
    *   函数 : 调用函数时产生, 函数执行完时死亡
*   包含哪些属性:
    *   全局 :
        *   用 var 定义的全局变量 ==> undefined
        *   使用 function 声明的函数 ==> function
        *   this ==> window
    *   函数
        *   用 var 定义的局部变量 ==> undefined
        *   使用 function 声明的函数 ==> function
        *   this ==> 调用函数的对象, 如果没有指定就是 window
        *   形参变量 ==> 对应实参值
        *   arguments ==> 实参列表的伪数组
*   执行上下文创建和初始化的过程
    *   全局:
        *   在全局代码执行前最先创建一个全局执行上下文 (window)
        *   收集一些全局变量, 并初始化
        *   将这些变量设置为 window 的属性
    *   函数:
        *   在调用函数时, 在执行函数体之前先创建一个函数执行上下文
        *   收集一些局部变量, 并初始化
        *   将这些变量设置为执行上下文的属性
        

**作用域与作用域链：**

*   理解:
    *   作用域: 一块代码区域, 在编码时就确定了, 不会再变化
    *   作用域链: 多个嵌套的作用域形成的由内向外的结构, 用于查找变量
*   分类:
    *   全局
    *   函数
    *   js 没有块作用域 (在 ES6 之前)
*   作用
    *   作用域: 隔离变量, 可以在不同作用域定义同名的变量不冲突
    *   作用域链: 查找变量
*   区别作用域与执行上下文
    *   作用域: 静态的, 编码时就确定了 (不是在运行时), 一旦确定就不会变化了
    *   执行上下文: 动态的, 执行代码时动态创建, 当执行结束消失
    *   联系: 执行上下文环境是在对应的作用域中的

**闭包：**

*   理解:
    *   当嵌套的内部函数引用了外部函数的变量时就产生了闭包
    *   通过 chrome 工具得知: 闭包本质是内部函数中的一个对象, 这个对象中包含引用的变量属性
*   作用:
    *   延长局部变量的生命周期
    *   让函数外部能操作内部的局部变量
*   写一个闭包程序
    
    ```
    function fn1() {
      var a = 2;
      function fn2() {
        a++;
        console.log(a);
      }
      return fn2;
    }
    var f = fn1();
    f();
    f();
    ```
    
*   闭包应用:
    *   模块化: 封装一些数据以及操作数据的函数, 向外暴露一些行为
    *   循环遍历加监听
    *   JS 框架 (jQuery) 大量使用了闭包
*   缺点:
    *   变量占用内存的时间可能会过长
    *   可能导致内存泄露
    *   解决:
        *   及时释放：`f = null; //让内部函数对象成为垃圾对象`

**内存溢出与内存泄露：**

*   内存溢出
    *   一种程序运行出现的错误
    *   当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误
*   内存泄露
    *   占用的内存没有及时释放
    *   内存泄露积累多了就容易导致内存溢出
    *   常见的内存泄露:
        *   意外的全局变量
        *   没有及时清理的计时器或回调函数
        *   闭包

▲对象高级
=====

对象创建模式
------

### Object 构造函数模式

![](https://img-blog.csdnimg.cn/20190731201111234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

### 对象字面量

![](https://img-blog.csdnimg.cn/20190731201127372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

### 工厂模式

![](https://img-blog.csdnimg.cn/20190731201159993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

### 自定义构造函数模式

![](https://img-blog.csdnimg.cn/20190731201255949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

### 构造函数 + 原型的组合模式

![](https://img-blog.csdnimg.cn/20190731201350642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

继承模式
----

### 原型链继承

![](https://img-blog.csdnimg.cn/20190731201414501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190731201430596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

### 借用构造函数继承

![](https://img-blog.csdnimg.cn/20190731201534546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

### 组合继承

![](https://img-blog.csdnimg.cn/20190731201549252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

### 对象高级总结

**对象的创建模式：**

*   Object 构造函数模式
    
    ```
    var obj = {};
    obj.name = 'Tom'
    obj.setName = function(name){this.name=name}
    ```
    
*   对象字面量模式
    
    ```
    var obj = {
      name : 'Tom',
      setName : function(name){this.name = name}
    }
    ```
    
*   构造函数模式
    
    ```
    function Person(name, age) {
      this.name = name;
      this.age = age;
      this.setName = function(name){this.name=name;};
    }
    new Person('tom', 12);
    ```
    
*   构造函数 + 原型的组合模式
    
    ```
    function Person(name, age) {
      this.name = name;
      this.age = age;
    }
    Person.prototype.setName = function(name){this.name=name;};
    new Person('tom', 12);
    ```
    

**继承模式：**

*   原型链继承 : 得到方法
    
    ```
    function Parent(){}
    Parent.prototype.test = function(){};
    function Child(){}
    Child.prototype = new Parent(); // 子类型的原型指向父类型实例
    Child.prototype.constructor = Child
    var child = new Child(); //有test()
    ```
    
*   借用构造函数 : 得到属性
    
    ```
    function Parent(xxx){this.xxx = xxx}
    Parent.prototype.test = function(){};
    function Child(xxx,yyy){
        Parent.call(this, xxx);//借用构造函数   this.Parent(xxx)
    }
    var child = new Child('a', 'b');  //child.xxx为'a', 但child没有test()
    ```
    
*   组合
    
    ```
    function Parent(xxx){this.xxx = xxx}
    Parent.prototype.test = function(){};
    function Child(xxx,yyy){
        Parent.call(this, xxx);//借用构造函数   this.Parent(xxx)
    }
    Child.prototype = new Parent(); //得到test()
    var child = new Child(); //child.xxx为'a', 也有test()
    ```
    
*   new 一个对象背后做了些什么?
    *   创建一个空对象
    *   给对象设置`__proto__`,  
        值为构造函数对象的 prototype 属性值 `this.__proto__ = Fn.prototype`
    *   执行构造函数体 (给对象添加属性 / 方法)

▲线程机制与事件机制
==========

进程与线程
-----

![](https://img-blog.csdnimg.cn/20190731202121288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190731202133482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190731202145328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190731202155534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

浏览器内核
-----

![](https://img-blog.csdnimg.cn/20190731202215214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

定时器引发的思考
--------

![](https://img-blog.csdnimg.cn/20190731202238709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190731202249358.png)  
【大致意思是这样】后面会知道，定时器延时是因为，定时器相关的回调函数被调用后会进入回调队列，且进入队列后需要先将排在前面的初始化代码及其他的代码执行完后才能再执行该定时器相关的代码（因为 JS 是单线程的），因此会有延迟，而排在前面的代码及其运行的时间往往是不同的，因此也就造成延迟时间的不同。

JS 是单线程的
--------

![](https://img-blog.csdnimg.cn/20190731202348832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

浏览器的事件循环 (轮询) 模型
----------------

![](https://img-blog.csdnimg.cn/20190731204529192.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190731204539925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190731204606420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

H5 Web Workers 多线程
------------------

例如，网页在有弹出框时，无法再操作网页中的 “计算按钮”，如图所示，如果计算时间较长，则用户较长时间内无法对网页进行其他操作，原因是网页界面的更新只能由主线程进行，而 JS 是单线程的，因此，网页只能等主线程完成计算之后再去更新界面。  
![](https://img-blog.csdnimg.cn/20190731204629331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190731204638795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190731204648447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190731204657257.png)  
![](https://img-blog.csdnimg.cn/20190731204706223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
**下面为具体示例：**

未使用 H5 分线程：  
![](https://img-blog.csdnimg.cn/20190731204742648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
使用 H5 分线程：  
![](https://img-blog.csdnimg.cn/20190731204757655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)  
![](https://img-blog.csdnimg.cn/20190731204811559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VhcnRoT0x0YWluYW53YW4=,size_16,color_FFFFFF,t_70)

线程机制与事件机制总结
-----------

**线程与进程:**

*   进程:
    *   程序的一次执行, 它占有一片独有的内存空间
    *   可以通过 windows 任务管理器查看进程
*   线程:
    *   是进程内的一个独立执行单元
    *   是程序执行的一个完整流程
    *   是 CPU 的最小的调度单元
*   关系
    *   一个进程至少有一个线程 (主)
    *   程序是在某个进程中的某个线程执行的

**浏览器内核模块组成:**

*   主线程
    *   js 引擎模块 : 负责 js 程序的编译与运行
    *   html,css 文档解析模块 : 负责页面文本的解析
    *   DOM/CSS 模块 : 负责 dom/css 在内存中的相关处理
    *   布局和渲染模块 : 负责页面的布局和效果的绘制 (内存中的对象)
*   分线程
    *   定时器模块 : 负责定时器的管理
    *   DOM 事件模块 : 负责事件的管理
    *   网络请求模块 : 负责 Ajax 请求

**js 线程:**

*   js 是单线程执行的 (回调函数也是在主线程)
*   H5 提出了实现多线程的方案: Web Workers
*   只能是主线程更新界面

**定时器问题:**

*   定时器并不真正完全定时
*   如果在主线程执行了一个长时间的操作, 可能导致延时才处理

**事件处理机制:**

*   代码分类
    *   初始化执行代码：包含绑定 dom 事件监听, 设置定时器, 发送 ajax 请求的代码
    *   回调执行代码：处理回调逻辑
*   js 引擎执行代码的基本流程:
    *   初始化代码 ==> 回调代码
*   模型的 2 个重要组成部分:
    *   事件管理模块
    *   回调队列
*   模型的运转流程
    *   执行初始化代码, 将事件回调函数交给对应模块管理
    *   当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中
    *   只有当初始化代码执行完后 (可能要一定时间)，才会遍历读取回调队列中的回调函数执行

**H5 Web Workers:**

*   可以让 js 在分线程执行
    
*   Worker
    
    ```
    var worker = new Worker('worker.js');
    worker.onMessage = function(event){event.data} : 用来接收另一个线程发送过来的数据的回调
    worker.postMessage(data1) : 向另一个线程发送数据
    ```
    
*   问题:
    
    *   worker 内代码不能操作 DOM 更新 UI
    *   不是每个浏览器都支持这个新特性
    *   不能跨域加载 JS
*   svn 版本控制
    
*   svn server